
# 索引

### `MySQL` 为什么使用 `B+` 树来作索引，对比 `B` 树它的优点和缺点是什么？

##### `B+`树和`B`数的定义？

- **`B`树定义**：`B`树是平衡搜索多叉树，设树的度为`2d(d>1)`，高度为`h`，那么`B`树要满足条件：
  - 每个叶子节点的高度一样，等于`h`
  - 每个非叶子结点由`n-1`个`key`和`n`个指针`point`组成，其中 `d<=n<=2d`，`key` 和 `point` 相互间隔，结点两端一定是 `key`
  - 叶子节点指针都为 `null`
  - 非叶子节点的`key`都是`[key, data]`二元组，其中`key`表示作为索引的键，`data`为键值所在行的数据
- **`B+`树定义**：`B+`树是`B`树的一个变种，设`d`为树的度数，`h`为树的高度，`B+`树和`B`树的不同主要在于：
  - `B+`树中的非叶子节点不存储数据，只存储键值
  - `B+`树的叶子节点没有指针，所有键值都会出现在叶子结点上，且`key`存储的键值对应`data`数据的物理地址
  - `B+`树的每个非叶子节由`n`个键值`key`和`n`个指针`point`组成

##### `B+`树和`B`树的区别？

- 查找结点的时间复杂度
  - `B`树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为`O(1)`，最坏为`O(logn)`
  - `B+`树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为`O(logn)`

- 查找方法
  - `B+`树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作
  - `B`树只能通过中序遍历

##### 为什么`B+`树比`B`树更适合应用于数据库索引？

- `B+`树更加适应磁盘的特性，相比`B`树减少了`I/O`读写的次数
  - 由于索引文件很大因此索引文件存储在磁盘上，`B+`树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查询的关键字也就越多，磁盘的随机`I/O`读取次数相对就减少了
- `B+`树的查询效率相比`B`树更加稳定
  - 由于数据只存在叶子结点上，所以查找效率固定为 `O(logn)`
- `B+`树利于扫库和范围查询
  - `B+`树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点
  - `B`树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫描。也就是说，对于范围查询和有序遍历而言，`B+`树的效率更高

------

### 唯一索引与普通索引的区别是什么？使用索引会有哪些优缺点？

##### 唯一索引和普通索引的区别是什么？

- 唯一索引和普通索引的区别是唯一索引定义了唯一性
- 从查询性能上对比，假如查询`k=5`的记录：
  - 对于普通索引来说，查到满足的第一个记录后，需要查找下一条记录，直到碰到第一个不满足`k=5`的条件，查询结束
  - 对于唯一索引，查到满足的第一个记录后，即可返回，查询结束
  - `InnoDB` 对于一条记录并不是将这条记录从磁盘中读出来，而是以页为单位，将整体读取到内存中，每个数据页的大小是`16kb`，那么对于一个`int`索引来说，一个数据存储的索引数据近千条，普通索引查询下一条需要读取两个数据页的几率很小。
  - 因此唯一索引和普通索引在查询的性能上差别不大
- 从更新性能上对比：
  - 当需要更新一个数据页时，如果数据页在内存中就直接更新
  - 如果数据页不在内存中，在不影响数据一致性的情况下，`InnoDB`会将这些更新操作缓存到 `change buffer`中，这样不需要从磁盘中读取数据页，减少磁盘读取，等到下一次查询时，先将原数据页的数据查到，然后再进行`merge`
  - 唯一索引，所有更新的操作都需要先判断操作是否违反了唯一性，所以必须将数据页读入内存才能判断，不能用到 `channge buffer`
  - 因此，在更新操作上，普通索引优于唯一索引

##### 使用索引会有哪些优缺点？

- 优点：
  - 索引相当于书的目录，能快速定位数据的位置，减少磁盘的`I/O` 操作
- 缺点：
  - 索引文件数据很大，必须存储在磁盘中，增加了磁盘的占用

------

### 聚簇索引和非聚簇索引有什么区别？什么情况用聚集索引？

------

### 索引覆盖、最左原则、索引下推

#### 简述什么是覆盖索引？

##### 概念

- 覆盖索引指的是，在使用索引查询时，需要查询的值已经在索引树上，因此可以直接提供查询结果，不需要回表。
- 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

##### 例子

```sql
/* id 为主键，c 为索引 */
SELECT id FROM T WHERE k BETWEEN 3 AND 5;
```

- 因为索引`k`的数据时`k+id`，包含了需要查询的值，不需要再回表，所以符合覆盖索引查询。


#### 简述什么是最左匹配原则？

##### 概念

- 最左匹配原则是指，在执行查询过程中，不需要索引的全部定义，只需要满足最左前缀，就可以利用索引来加速检测。
- 最左前缀可以是联合索引的最左`N`个字段，也可以是字符串索引的最左`M`个字符。

##### 例子

```sql
/* 联合索引，a, b, c */
SELECT * FROM T WHERE A=val1 /* A 符合最左匹配 */
SELECT * FROM T WHERE A=val1 AND B=val2 /* AB 符合最左匹配 */
SELECT * FROM T WHERE A=val1 AND C=val3 /* 该SQL会选择 A 作为索引去查询 */
SELECT * FROM T WHERE B=val1 AND C=val3 /* 没有用到索引，不符合 */

/* 假设 a 是字符串 */
SELECT * FROM T WHERE A="A%" /* 也是符合最左匹配原则的 */
```

##### 拓展

- 一个索引可以最多包含16列
- 取字符串的最左部分字符可以作为前缀索引，但是不能使用覆盖索引，因为索引查询时必须回表。


#### 假设建立联合索引 (a, b, c) 如果对字段 a 和 c 查询，会用到这个联合索引吗？

- 准确来说，查询字段`(a, c)` 的话，其中一部分字段会用到联合索引，也就是字段`a`，但`c`的部分没有使用索引。

- 从定义来说，我们说查询用到联合索引的话，一般指所有字段的查询都用到了该索引。也就是 `(a), (a,b),(a,b,c)` 这三种情况

  
#### 简述什么是索引下推？

##### 概念

索引下推是 `MySQL5.6` 引入的特性，指在索引遍历的过程中，在符合最左匹配原则情况下，对索引中包含的字段先进行判断，直接过来掉不满足条件的记录，减少回表次数。

##### 例子

```sql
/* 联合索引 (name, age) */
SELECT * FROM T WHERE name like 'A%' AND age = 10
```

- 在无索引下推的情况下，找到符合 `like A%` 的行，直接回表查主键的行记录，然后在判断 `age=10`
- 在有索引下推的情况下，先判断 `age = 10，再回表。

------

### 数据库有哪些常见索引？数据库设计的范式是什么？

------

### 简述一致性哈希算法的实现方式及原理

------

### `MySQL` 的索引什么情况下会失效？

------

### 数据库索引的实现原理是什么？

------

# 事务

### 数据库的事务隔离级别有哪些？各有哪些优缺点？

##### 数据库的事务隔离级别有哪些？

事务隔离级别主要有四种：

- 读未提交(`READ UNCOMMITED`)
  - 定义：一个事务可以读取另一个事务已修改但未提交的数据
  - 存在问题：脏读
- 读已提交(`READ COMMITED`)
  - 定义：一个事务只能读取另一个事务已经提交的数据
  - 存在问题：不可重复读
- 可重复读(`REPEATABLE READ`)，`MySQL` 默认隔离级别
  - 定义：在一个事务中多次读取同一条记录，结果一致，无论其他事务是否对这条记录做了修改
  - 存在问题：幻读
- 串行化(`SERIALIZABLE`)
  - 定义：所有事务顺序执行
  - 不存在脏读、不可重复读、幻读等问题

##### 各有哪些优缺点？

- 隔离级别从上到下，并发性能越来越差，但对于数据的隔离性一致性保证程度越好

##### 脏读定义

- 一个事务读到另一个事务已修改未提交的数据，如果前一个事务回滚或修改之前的值，读到的数据就是错误的

##### 不可重复读定义

- 事务`A`修改某条数据，事务`B` 在事务`A`提交前读取到的数据和提交后读取到的数据不一致

##### 幻读定义

- 在可重复度隔离级别下，普通的查询时快照度，是不会看到别的事务插入的数据的，幻读在当前读下才会出现，幻读仅专指新插入的行

------

### 什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项

------

### 简述脏读和幻读的发生场景，`InnoDB` 是如何解决幻读的？

##### 脏读发生的场景

- `MySQL`在读未提交的事务隔离级别下，可能会发生脏读
- 当把事务的隔离级别提升到读提交，则可以避免脏读

##### 幻读发生的场景

- 在可重复度隔离级别下，普通的查询时快照度，是不会看到别的事务插入的数据的，因此幻读在当前读下才会出现
- 幻读仅专指新插入的行，更新或删除的行在当前读下出现，不算幻读
- 当前读出现的方式
  - `update` 和 `delete` 语句
  - `select` 加读锁 `lock in share mode`
  - `select` 加写锁 `for update`

##### `InnoDB` 是如何解决幻读的？

- 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的间隙
- 为了解决幻读的问题，`InnoDB` 在引入间隙锁，间隙锁锁住了记录之间的间隙，在事务的可重复度隔离级别下，间隙锁才会生效
- 间隙锁和行锁合称临键锁( `Netx-Key Locks`)，是`InnoDB` 解决幻读的手段

------

### 并发事务会引发哪些问题？如何解决？

------

# 锁

### 简述乐观锁以及悲观锁的区别以及使用场景

------

### 什么情况下会发生死锁，如何解决死锁？

------

### 简述 `MySQL` 的间隙锁

- 间隙锁，顾名思义，锁的就是两个值之间的空隙，`InnoDB` 是为了解决幻读而引入的新锁
- 间隙锁是在可重复隔离级别下才会生效，如果把事务的隔离级别设置未读提交，就没有间隙锁
- 间隙锁之间不互锁，因为它们都是保护间隙，不允许锁住的间隙里插入值
- 间隙锁和行锁合称临键锁( `Netx-Key Locks`)，每个间隙锁是开区间的，`Netx-Key Locks` 是前开后闭区间

------

# 应用

### MySQL 有什么调优的方式？

------

### 简述 MySQL 的主从同步机制，如果同步失败会怎么样？

------

### 简述数据库中什么情况下进行分库，什么情况下进行分表？

------

### 什么是 SQL 注入攻击？如何防止这类攻击？

------

### MySQL 中 join 与 left join 的区别是什么？

------

### 数据库查询中左外连接和内连接的区别是什么？

------

### 模糊查询是如何实现的？

------

### SQL优化的方案有哪些，如何定位问题并解决问题？

------

# 特性

### 简述数据库中的 ACID 分别是什么？

------

### MySQL 有哪些常见的存储引擎？它们的区别是什么？

------

### 数据库反范式设计会出现什么问题？

------
### MySQL 中 varchar 和 char 的区别是什么？

------

# 持久化

### 简述 MySQL 三种日志的使用场景

------

### 简述 undo log 和 redo log 的作用

------

### 简述 MySQL MVCC 的实现原理

------

### 数据库的读写分离的作用是什么？如何实现？

------

### 简述什么是两阶段提交？

------

