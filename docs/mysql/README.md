
# 索引

### `MySQL` 为什么使用 `B+` 树来作索引，对比 `B` 树它的优点和缺点是什么？

##### `B+`树和`B`数的定义？

- **`B`树定义**：`B`树是平衡搜索多叉树，设树的度为`2d(d>1)`，高度为`h`，那么`B`树要满足条件：
  - 每个叶子节点的高度一样，等于`h`
  - 每个非叶子结点由`n-1`个`key`和`n`个指针`point`组成，其中 `d<=n<=2d`，`key` 和 `point` 相互间隔，结点两端一定是 `key`
  - 叶子节点指针都为 `null`
  - 非叶子节点的`key`都是`[key, data]`二元组，其中`key`表示作为索引的键，`data`为键值所在行的数据
- **`B+`树定义**：`B+`树是`B`树的一个变种，设`d`为树的度数，`h`为树的高度，`B+`树和`B`树的不同主要在于：
  - `B+`树中的非叶子节点不存储数据，只存储键值
  - `B+`树的叶子节点没有指针，所有键值都会出现在叶子结点上，且`key`存储的键值对应`data`数据的物理地址
  - `B+`树的每个非叶子节由`n`个键值`key`和`n`个指针`point`组成

##### `B+`树和`B`树的区别？

- 查找结点的时间复杂度
  - `B`树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为`O(1)`，最坏为`O(logn)`
  - `B+`树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为`O(logn)`

- 查找方法
  - `B+`树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作
  - `B`树只能通过中序遍历

##### 为什么`B+`树比`B`树更适合应用于数据库索引？

- `B+`树更加适应磁盘的特性，相比`B`树减少了`I/O`读写的次数
  - 由于索引文件很大因此索引文件存储在磁盘上，`B+`树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查询的关键字也就越多，磁盘的随机`I/O`读取次数相对就减少了
- `B+`树的查询效率相比`B`树更加稳定
  - 由于数据只存在叶子结点上，所以查找效率固定为 `O(logn)`
- `B+`树利于扫库和范围查询
  - `B+`树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点
  - `B`树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫描。也就是说，对于范围查询和有序遍历而言，`B+`树的效率更高

##### 拓展：`B+ Tree VS ` 红黑树

- 更少的查找次数：红黑树是二叉树，导致同样的数量的`data`，红黑树的高度会大于 `B+ Tree`
- 减少磁盘寻道：因为磁盘不是严格读取数据，而是会有预读的情况。顺序读取的过程中不需要磁盘寻道，速度更快

------

### 唯一索引与普通索引的区别是什么？使用索引会有哪些优缺点？

##### 区别

- 唯一索引和普通索引的区别是唯一索引定义了唯一性
- 从查询性能上对比，假如查询`k=5`的记录：
  - 对于普通索引来说，查到满足的第一个记录后，需要查找下一条记录，直到碰到第一个不满足`k=5`的条件，查询结束
  - 对于唯一索引，查到满足的第一个记录后，即可返回，查询结束
  - `InnoDB` 对于一条记录并不是将这条记录从磁盘中读出来，而是以页为单位，将整体读取到内存中，每个数据页的大小是`16kb`，那么对于一个`int`索引来说，一个数据存储的索引数据近千条，普通索引查询下一条需要读取两个数据页的几率很小。
  - 因此唯一索引和普通索引在查询的性能上差别不大
- 从更新性能上对比：
  - 当需要更新一个数据页时，如果数据页在内存中就直接更新
  - 如果数据页不在内存中，在不影响数据一致性的情况下，`InnoDB`会将这些更新操作缓存到 `change buffer`中，这样不需要从磁盘中读取数据页，减少磁盘读取，等到下一次查询时，先将原数据页的数据查到，然后再进行`merge`
  - 唯一索引，所有更新的操作都需要先判断操作是否违反了唯一性，所以必须将数据页读入内存才能判断，不能用到 `channge buffer`
  - 因此，在更新操作上，普通索引优于唯一索引

##### 使用索引会有哪些优缺点？

- 优点
  - 创建唯一性索引，保证数据库表中该列的唯一性
  - 大大加快数据的检索速度
  - 加速表和表之间的连接
  - 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
  - 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能，例如：`COUNT(*)`

- 缺点
  - 创建和维护索引要耗费时间，这种时间随着数量的增加而增加
  - 索引需要占物理空间，除了数据表占数据空间外，每一个索引还要占一定的物理空间
  - 当对表中的数据进行增加、删除和修改时，索引也要动态维护，降低了数据的维护速度

------

### 数据库有哪些常见索引？

##### 从数据结构角度

- `B+Tree`索引：`MySQL`默认索引，可用于查找、分组、排序
- `Hash`索引：基于哈希表实现，适合新增和等值查询，不是有序的，范围查询很慢，必须全表扫描；
- `FULLTEXT`索引:大量文件检索时，需要用全文索引，因为它的速度是 `like`的 `N`倍(`MySQL 5.6`版本`InnoDB`支持)
- `R-Tree`索引：空间数据索引会从所有维度来索引数据，主要用于地理数据存储。

##### 从物理存储角度

- 聚簇索引：叶子结点存放一整行记录
- 非聚簇索引：叶子节点存放索引+指向行数据的指针

##### 从逻辑角度

- 主键索引：是一种特殊的唯一索引，不允许有空值
- 普通索引/单列索引
- 复合索引/多列索引：多个字段上创建的索引，在查询条件中，使用第一个字段，所以才会被使用，符合最左原则
- 唯一索引：该列值不能重复

------

### 数据库索引的实现原理是什么？

- 索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。

------

### 聚簇索引和非聚簇索引有什么区别？什么情况用聚集索引？

#### 区别

- 聚簇索引与非聚簇索引的区别是：叶节点是否存放行数据

##### 聚簇索引

- 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。比如：`InnoDB`的聚簇索引使用`B+Tree`的数据结构存储索引和数据
- 当表有聚簇索引时，它的数据行实际存放在索引的叶子页。因为无法同时把数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。
- 聚簇索引的二级索引：叶子节点不会保存引用的行的物理位置，而是保存行的主键位置

##### 非聚簇索引

- 表数据存储顺序与索引顺序无关，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

##### 聚簇索引的优点

- 可以把相关数据保存在一起
- 访问数据更快
- 使用覆盖索引扫描的查询可以直接使用页借点的主键值

##### 聚簇索引的缺点

- 聚簇索引数据最大限度地提高`IO`密集性应用的性能，但如果把数据全部放在内存中，则访问的顺序没那么重要，聚簇索引就没什么优势了
- 插入速度严重依赖插入顺序
- 更新聚簇索引列的代价很高
- 基于索引的表插入新行，或主键被更新导致需要移动行的时候，可能面临页分裂
- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续

#### 使用场合

##### 聚簇索引的使用场合

- 查询命令的回传结果是以该字段为排序依据的
- 查询的结果返回一个区间值
- 查询的结果返回某值相同的大量结果集

##### 非聚簇索引的使用场合

- 查询所获数据量较少时
- 某个字段中的数据的唯一性比较高时

#### 拓展：`InnoDB`的主键列

- 如果没有定义主键，`InnoDB`会选择一个唯一的非空索引代替
- 如果没有这样的索引，`InnoDB`会隐式定义一个主键作为聚簇索引

#### 拓展：为什么主键通常建议使用自增 `id`

- 聚簇索引的数据的物理存放顺序与索引的顺序一致。即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上
- 如果主键不是自增 `id`，那么需要不断调整数据的物理地址、分页等；
- 如果是自增的，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高
- 
------

### 索引覆盖、最左原则、索引下推

#### 简述什么是覆盖索引？

##### 概念

- 覆盖索引指的是，在使用索引查询时，需要查询的值已经在索引树上，因此可以直接提供查询结果，不需要回表。
- 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

##### 例子

```sql
/* id 为主键，c 为索引 */
SELECT id FROM T WHERE k BETWEEN 3 AND 5;
```

- 因为索引`k`的数据时`k+id`，包含了需要查询的值，不需要再回表，所以符合覆盖索引查询。


#### 简述什么是最左匹配原则？

##### 概念

- 最左匹配原则是指，在执行查询过程中，不需要索引的全部定义，只需要满足最左前缀，就可以利用索引来加速检测。
- 最左前缀可以是联合索引的最左`N`个字段，也可以是字符串索引的最左`M`个字符。

##### 例子

```sql
/* 联合索引，a, b, c */
SELECT * FROM T WHERE A=val1 /* A 符合最左匹配 */
SELECT * FROM T WHERE A=val1 AND B=val2 /* AB 符合最左匹配 */
SELECT * FROM T WHERE A=val1 AND C=val3 /* 该SQL会选择 A 作为索引去查询 */
SELECT * FROM T WHERE B=val1 AND C=val3 /* 没有用到索引，不符合 */

/* 假设 a 是字符串 */
SELECT * FROM T WHERE A="A%" /* 也是符合最左匹配原则的 */
```

##### 拓展

- 一个索引可以最多包含16列
- 取字符串的最左部分字符可以作为前缀索引，但是不能使用覆盖索引，因为索引查询时必须回表。


#### 假设建立联合索引 (a, b, c) 如果对字段 a 和 c 查询，会用到这个联合索引吗？

- 准确来说，查询字段`(a, c)` 的话，其中一部分字段会用到联合索引，也就是字段`a`，但`c`的部分没有使用索引。

- 从定义来说，我们说查询用到联合索引的话，一般指所有字段的查询都用到了该索引。也就是 `(a), (a,b),(a,b,c)` 这三种情况

  
#### 简述什么是索引下推？

##### 概念

索引下推是 `MySQL5.6` 引入的特性，指在索引遍历的过程中，在符合最左匹配原则情况下，对索引中包含的字段先进行判断，直接过来掉不满足条件的记录，减少回表次数。

##### 例子

```sql
/* 联合索引 (name, age) */
SELECT * FROM T WHERE name like 'A%' AND age = 10
```

- 在无索引下推的情况下，找到符合 `like A%` 的行，直接回表查主键的行记录，然后在判断 `age=10`
- 在有索引下推的情况下，先判断 `age = 10，再回表。

------

### `MySQL` 的索引什么情况下会失效？

- 联合索引，没有使用最左匹配原则
  -例如：联合索引`(a, b)`，`SELECT * FROM T WHERE b = 1`
  - 因为索引都是先基于`a`排序的，`a`相同的情况，再基于`b`排序，所以查询条件没有`a`，对于索引来说，`b`是无序的，所以索引失效；

- 范围查询，右边失效
  -  例如：联合索引`(a, b)`, `SELECT * FROM T WHERE a > 1 AND b = 1`
  -  字段`a` 在 `B+ Tree`上是有序的，可以用二分查找去定位，`a`的索引能被用到，`b`有序的前提是 `a`是确定值，在之前逻辑中，`b`是无序的，所以`b`用不到索引

- `like`的 `%` 放在左边，索引失效
  - 例如：`SELECT * FROM T WHERE a LIKE "%a"`
  - 字符串的排序方式是，先按照第一个字母排序，如果第一个字母相同，就按照第二个字母排序，依次类推

- 条件字段做函数操作，导致索引失效
  - 对索引字段做函数操作，可能会破坏索引的有序性，优化器一刀切，不管有没有破坏有序性，都不会考虑使用索引
  
- 隐式转换，导致索引失效
  - 数据类型转换，如果字符串和数字比较，则将字符串转换成数字
  - 如果条件条件字段是字符串，查询条件是数字，则会隐式的将字符串转为数字，即对字段做函数操作

------

# 事务

### 什么是数据库事务，简述数据库中的 `ACID` 分别是什么？

##### 事务的概念

- 数据库事务是指一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 `ACID`（原子性、一致性、隔离性和持久性）属性

##### `ACID`

- `ACID`是指数据库在写入或更新资料的过程中，为了保证事务时正确可靠的，所必须具备的四个特性：`A`代表原子性，`C`代表一致性，`I`代表隔离性，`D`代表持久性
- `A`：(`Atomicity`)原子性
  - 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；
  - 事务在执行过程中发生错误，会被回滚(`Rollback`)到事务开始前的状态；
- `C`:(`Consistency`)一致性
  - 在事务开始之前和事务结束以后，数据库的完整性没有被破坏；
- `I`:(`Isolation`)隔离性
  - 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据不一致。
  - 事务的隔离分为不同级别：读未提交、读提交、可重复读、串行化
- `D`:(`Durability`)耐用性
  - 事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失。

------

### 数据库的事务隔离级别有哪些？各有哪些优缺点？

##### 数据库的事务隔离级别有哪些？

事务隔离级别主要有四种：

- 读未提交(`READ UNCOMMITED`)
  - 定义：一个事务可以读取另一个事务已修改但未提交的数据
  - 存在问题：脏读
- 读已提交(`READ COMMITED`)
  - 定义：一个事务只能读取另一个事务已经提交的数据
  - 存在问题：不可重复读
- 可重复读(`REPEATABLE READ`)，`MySQL` 默认隔离级别
  - 定义：在一个事务中多次读取同一条记录，结果一致，无论其他事务是否对这条记录做了修改
  - 存在问题：幻读
- 串行化(`SERIALIZABLE`)
  - 定义：所有事务顺序执行
  - 不存在脏读、不可重复读、幻读等问题

##### 各有哪些优缺点？

- 隔离级别从上到下，并发性能越来越差，但对于数据的隔离性一致性保证程度越好

##### 脏读定义

- 一个事务读到另一个事务已修改未提交的数据，如果前一个事务回滚或修改之前的值，读到的数据就是错误的

##### 不可重复读定义

- 事务`A`修改某条数据，事务`B` 在事务`A`提交前读取到的数据和提交后读取到的数据不一致

##### 幻读定义

- 在可重复度隔离级别下，普通的查询时快照度，是不会看到别的事务插入的数据的，幻读在当前读下才会出现，幻读仅专指新插入的行

------

### `MySQL` 为什么会使用 `InnoDB` 作为默认选项

------

### 简述脏读和幻读的发生场景，`InnoDB` 是如何解决幻读的？

##### 脏读发生的场景

- `MySQL`在读未提交的事务隔离级别下，可能会发生脏读
- 当把事务的隔离级别提升到读提交，则可以避免脏读

##### 幻读发生的场景

- 在可重复度隔离级别下，普通的查询时快照度，是不会看到别的事务插入的数据的，因此幻读在当前读下才会出现
- 幻读仅专指新插入的行，更新或删除的行在当前读下出现，不算幻读
- 当前读出现的方式
  - `update` 和 `delete` 语句
  - `select` 加读锁 `lock in share mode`
  - `select` 加写锁 `for update`

##### `InnoDB` 是如何解决幻读的？

- 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的间隙
- 为了解决幻读的问题，`InnoDB` 在引入间隙锁，间隙锁锁住了记录之间的间隙，在事务的可重复度隔离级别下，间隙锁才会生效
- 间隙锁和行锁合称临键锁( `Netx-Key Locks`)，是`InnoDB` 解决幻读的手段

------

### 并发事务会引发哪些问题？如何解决？

------

# 锁

### 简述乐观锁以及悲观锁的区别以及使用场景

#### 区别

##### 乐观锁

- 乐观锁在数进行提交更新的时候，才会正式对数据的冲突与否进行检测；
- 在对数据库进行处理的时候，乐观锁并不会使用数据库的锁机制；
- 一般实现乐观锁的方式就是记录版本号，更新数据同步更新版本号，如果发现版本号不一致，则说明数据被其他线程修改了，本次更新不成功
- 乐观锁不会产生死锁，拥有更好的性能

```sql
UPDATE t SET k = 1, version = version + 1 WHERE id = ? AND version = ?
```

##### 悲观锁

- 当我们要对一个数据库中的一条数据进行修改时，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发
- 悲观锁并发控制实际上是，先取锁再访问的保守策略，为数据处理的安全提供了保证；
- `InnoDB`的行锁分为共享锁和排他锁，两种锁都是悲观锁；
- 共享锁：又称读锁。当一个事务对一条数据加了读锁后，其他事务也能来读数据，可以共享一把锁 
```sql
SELECT * FROM t WHERE id = 1 lock in share mode;
```

- 排他锁：又称写锁。当一个事务对一条数据加了写锁后，其他事务想来访问这条数据只能阻塞等待锁的释放，具有排他性
  - `MySQL`的`SELECT FOR UPDATE`、`INSERT`、`UPDATE`、`DELETE` 都会加锁写锁
```sql
SELECT * FROM t WHERE id = 1 for update;
```

#### 使用场景

##### 乐观锁的使用场景

- 比较适合读取操作比较频繁的场景；
- 如果出现大量的写入操作，数据发生冲突的可能性就会增大：
  - 为了保证数据的一致性，应用层需要不断的重新获取数据
  - 这样会增加大量的查询操作，降低了系统的吞吐量
  
##### 悲观锁的使用场景

- 比较适合写入操作比较频繁的场景；
- 如果出现大量的读取操作，每次读取的时候都会进行加锁：
  - 这样会增加大量的锁的开销，降低了系统的吞吐量
------

### 什么情况下会发生死锁，如何解决死锁？

#### 发生死锁的情况

- 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，即出现死锁。

#### 解决死锁

##### 方式一：超时机制

- 两个事务互相等待时，当一个等待时间超过设置的某一个阈值，其中一个事务进行回滚，另一个等待的事务就能继续进行。
- `InnoDB`引擎中，参数`innodb_lock_wait_timeout`用来设置事务的超时时间。
- 缺点：根据`FIFO`的顺序选择回滚对象，无法自主选择
  - 如果超时的事务所占权重比较大，如果事务操作更新了很多行，占用了较多的`undo log`；
  - 这时候回滚这个事务的时间相对另一个事务所占用的时间可能会更多
 
##### 方式二：`wait-for graph`(等待图)

- `InnoDB`采用的死锁检测方式，是一种较为主动的死锁检测方式；
- 在每个事务请求锁并发生等待时，都会判断是否存在回路，如果存在则会有死锁；
- `InnoDB`引擎会选择`undo`量最小的事务进行回滚。

------

### 简述 `MySQL` 的间隙锁

- 间隙锁，顾名思义，锁的就是两个值之间的空隙，`InnoDB` 是为了解决幻读而引入的新锁
- 间隙锁是在可重复隔离级别下才会生效，如果把事务的隔离级别设置未读提交，就没有间隙锁
- 间隙锁之间不互锁，因为它们都是保护间隙，不允许锁住的间隙里插入值
- 间隙锁和行锁合称临键锁( `Netx-Key Locks`)，每个间隙锁是开区间的，`Netx-Key Locks` 是前开后闭区间

------

# 应用

### `MySQL` 有什么调优的方式？

------

### 什么是 `SQL` 注入攻击？如何防止这类攻击？

##### 概念

- 通过执行恶意 `SQL`，进而将任意`SQL`代码插入数据库查询，从而使攻击者完全控制 `Web` 应用程序后台的数据库服务器；
- 攻击者可以使用 `SQL` 注入漏洞绕过应用程序验证，比如绕过登录验证登录`Web`身份验证和授权页面；也可以绕过网页，直接检索数据库的所有内容；
- 还可以恶意修改、删除和增加数据库内容

##### 防止

- 不要信任用户的输入
  - 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。
    - `SQL`对前`''`作为值，后`''`可以插入另外一个`SQL`
    - 双`-`则会注释后面的查询条件
  - 不要使用动态拼装`SQL`，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取
  - 不要使用管理员权限的数据库连接，为每个应用使用单独的权限、有限的数据库连接
  - 不要把机密信息直接存放，加密或`HASH`掉密码和敏感的信息；
  - 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。

------

### `MySQL` 中 `join`、`left join`、`right join` 的区别是什么？

##### `join/inner join`：内连接

```sql
SELECT * FROM a JOIN a ON a.id = b.id
```

- `join`是`inner join`的简写
- 表示以两个表的交集为主，查出来的是两个表有交集的部分

###### `left join`：左连接

```sql
SELECT * FROM a LEFT JOIN a ON a.id = b.id
```

- 表`a`左连接表`b`，以左表`a`为主，关联上右表`b`，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据

###### `right join`：右连接

```sql
SELECT * FROM a RIGHT JOIN a ON a.id = b.id
```

- 表`a`右连接表`b`，以右表`b`为主，关联上左表`a`，查出来的结果显示右边的所有数据，然后左边显示的是和右边有交集部分的数据

------

### 模糊查询是如何实现的？

------

### `SQL`优化的方案有哪些，如何定位问题并解决问题？

------

# 特性

### MySQL 有哪些常见的存储引擎？它们的区别是什么？

------

### 数据库设计的范式是什么？

- 第一范式：每个列都不可以再拆分
- 第二范式：在第一范式基础上，非主键列完全依赖于主键，而不能依赖主键的一部分
- 第三范式：在第二范式基础上，非主键只依赖主键，不依赖于其他非主键，即没有传递关系

------

### 数据库反范式设计会出现什么问题？

##### 反范式设计会出现的问题

- 存在大量冗余数据，数据维护成本更高，可能伴随者删除异常、插入异常、更新异常

##### 不符合第二范式的例子

- 例如：在选课关系表(学号，课程号，成绩，学分)，主键为(学号，课程号)
- 但是非主属性学分仅仅依赖于课程，对主键仅依赖一部分，不是完全依赖，不符合第二范式(`2NF`)
- 存在问题：
  - 数据冗余：每条记录都含有相同信息(学分)
  - 删除异常：删除所有的学生成绩，就把课程信息全删除了
  - 插入异常：学生未选课，则没有课程信息
  - 更新异常：调整课程学分，所有行都调整
- 调整方法
  - 选课关系表(学号，课程号，分数)
  - 课程表(课程号，学分)

##### 不符合第三范式的例子

- 例如：学生表(学号、姓名、年龄、学院名称、学院电话)
- 该表存在学院电话不依赖学号，依赖学院名称，存在传递关系，所以不符合第三范式
- 可能存在的问题
  - 数据冗余：每条记录都含有相同信息
  - 更新异常：修改学院电话时，要更新所有包含该学院的记录
- 调整后的表
  - 学生表：(学号，姓名，年龄，所在学院)
  - 学院表：(学院，电话)
  
##### 反范式化的优点

- 数据冗余将带来很好的读取性能(以空间换时间，因为不需要`join`很多表)
- 例如：学生表与选课表，假定选课表要经常被查询，而且在查询中要显示学生姓名，如果这个需要被大范围、高频率的执行，可能会因为表关联造成一定程度的影响
- 现在评估学生改名的需求很少，那么可以把学生姓名冗余到选课表中。

------
### `MySQL` 中 `varchar` 和 `char` 的区别是什么？

##### 区别一：定长和变长

- `char` 定义的列为长度固定的字符串
  - 当所插入的字符串长度超出定义的长度时，如果时严格模式，则会拒绝插入并提示错误信息，如果是非严格模式，则会截断然后插入；
  - 当所插入的字符串长度小于定义的长度是，则将在它们的右边填充空格以达到指定的长度，在检索到的值，拖尾的空格被删除；
- `varchar` 定义的列为长度可变字符串
  - 占用的字节空间分为长度前缀+字符实际大小，长度前缀为当字符串实际的字节数，当字节数大于255时，则用2个字节去存储其长度，否则使用1个字节去存储；（`M+1/2`)

##### 区别二：存储的容量不同

- `char`存储的字符个数在 `0～255`之间，和编码无关
- `varchar` 存储的字符个数在 `0～65532`，`varchar`的最大有效长度由最大行大小和使用字符集确定
  - 行长度限制，`MySQL`要求一个行的定义长度不能超过65535字节
  - `varchar`字符类型使用1个字节来保存控制信息(65532=65535-1-2[长度信息])
  - 编码长度限制
    - 字符类型是`gbk`，每个字符最多占2个字节，最大长度不能能超过`32766`；
    - 字符类型是`utf8`,每个字符最多占3个字节，最大长度不能超过`21845`；
    - 定义时超过限制，则`varchar`字段会被强行转为`text`类型

------

# 持久化

### 简述 MySQL 三种日志的使用场景(作用)

- 我们经常讲的 `MySQL`三种日志是：`binlog`、`redo log`、`undo log`，其中`redo log`和`undo log` 是`InnDB`的实现关键

##### `binlog`的使用场景

- `binlog` 是 `MySQL Server` 层维护的一种二进制日志，其主要是用来记录`MySQL`数据更新或潜在发生更新的`SQL`语句，并以"事务"的形式保存在磁盘中；
- `binlog`的使用场景是：
  - 主从复制：`MySQL` 复制是 `Master`端开启`binlog`，`Master`把它的二进制日志传递给`Slaves`，并在`Slaves`端回放来达到`Master-Slave`数据一致的目的
  - 数据恢复：通过`mysqlbinlog` 工具恢复数据
  - 增量备份：`binlog` 是通过追加的方式进行写入的，可以通过 `max_binlog_size`参数设置每个`binlog`文件的大小，当文件大小到达给定值后，会生成新的文件来保存日志；

#### `redo log` 的使用场景

- 在 `InnoDB`中，数据一致性由`redo log`来保证，使用的是`WAL(Write-Ahead Logging)`机制，即先写日志再写数据；
- `InnoDB` 使用这种方式在进行故障恢复时，会将 `redo log`中的日志重做一遍，也就是将系统中未提交的事务重新执行；
- 默认情况下，`redo log`记录在`ib_logfile0` 和 `ib_logfile1`两个文件，分别用`write pos` 记录写入位置；
- 用`checkpoint`记录整个系统当前日志已经同步的位置，`checkpoint`保证了未提交的事务重新执行。

##### `undo log` 的使用场景

- `undo log`是事务原子性的保证，主要作用是回滚和多版本控制(`MVCC`)
- `undo log`主要记录了数据的逻辑变化，比如：一条`INSERT`语句，对应一条`DELETE`的`undo log`；
- 如果用户执行的事务或语句由于某种原因失败了，可以利用这些`undo`信息将数据回滚到修改前的数据状态；
- `MVCC`也是通过`undo log`来保证快照读的逻辑。

##### 拓展：`binlog`相关

- 查询 `binlog`日志的两种方式
  - 原因：`binlog`日志是二进制格式，无法直接进行查看
  - `mysqlbinlog`:`/usr/bin/mysqlbinlog mysql-bin.000009`
  - 命令解析 `SHOW BINLOG EVENTS [IN 'binlog_name']`
- `MySQL` 通过`sync_binlog`控制刷盘时机
  - 0(系统自行判断)，1(每次`commit`都会写入)，`N`(每`N`次事务才写入)
  - `MySQL 5.7.7`后默认设置为`1`
- `binlog` 日志格式
  - `STATMENT` ：基于 `SQL` 语句的复制，每一条会修改数据的 `SQL` 语句会记录到 `binlog` 中
    - 优点：不需要记录每一行的变化，减少了日志量
    - 缺点： 在某些情况下会导致主从数据不一致
  - `ROW`：基于行的复制，仅需要记录哪条数据被修改了
    - 优点： 不会出现某些特定情况下无法被正确复制的问题
    - 缺点： 会产生大量的日志，尤其是 alter table 的时候会让日志暴涨
  - `MIXED`：混合模式

##### 拓展：`redo log` 和 `binlog` 的区别

- `redo log` 是 `InnoDB` 引擎特有；`binlog`是`MySQL`的`Server`层实现的，所有引擎都可以用
- `redo log` 是物理日志，记录的是"在某个数据页上做了什么修改"; `binlog` 是逻辑日志，记录的是这个语句的原始逻辑，比如："给`ID=2`的行`c`字段加1"
- `redo log` 是循环写的，空间固定会用完；`binlog`是可以追加写的，当文件大小到达`max_binlog_size`值后，会生成新的文件来保存日志
- `binlog`适用于崩溃恢复(`crash-safe`), `binlog`日志适用于主从复制和数据恢复


##### 拓展：`redo log` 和`undo log`的区别

- `redo log` 和 `undo log` 都是用来恢复日志，但不是逆向过程
- `redo log`是物理日志，记录的是数据页的物理修改；`undo log`是逻辑日志，用来回滚行记录到某个版本，根据每行记录进行记录
- `redo log` 是读顺序写的， `undo log`是随机读写

##### 拓展：数据恢复

##### 拓展：正常运行中的实例，数据写入的最终落盘，是从`redo log`更新过来的吗？

- `redo log`并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就是不存在：数据最终落盘，是由`redo log`更新过去的情况；
- 如果是正常运行的实例
  - 数据页被修改后，跟磁盘的数据页不一致，称为脏页；
  - 最终数据落盘，就是把内存中的数据页写盘；
- 在崩溃恢复场景中
  - `InnoDB` 如果判断一个数据页可能在崩溃的时候丢失了更新，就会将它读到内存，然后让`redo log`更新内存内容
  - 更新完成后，内存页变成脏页，脏页旧回到上面的情况
  
##### 拓展：什么时候写`redo log buffer`，什么时候写`redo log file`

- `redo log buffer` 就是一块内存，用来先存`redo`日志的，也就是说，在数据的内存被修改了(执行写入操作)，`redo log buffer` 也写入日志；
- `redo log file` 是在执行 `commit`语句是做的

------

### 简述 `MySQL MVCC` 的实现原理

##### 概念

- `MVCC`，多版本并发控制。在`MySQL InnoDB` 中主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

##### 实现原理

- 在可重复读隔离级别下，事务启动相当于拍了个快照；
- 为了实现快照功能，`InnoDB`内部为每一行添加了两个隐藏字段：该行最后修改的事务`ID`(`DB_TRX_ID`) 和 回滚指针(`DB_ROLL_PTR`);
- `InnDB`里每个事务都要一个严格递增的事务`ID`，每次事务更新时，都会生成一个新的数据版本，把事务`ID`保存在 `DB_TRX_ID`中；
- 旧的数据保存`undo log`中，并把该`undo log`的指针保存在`DB_ROLL_PTR`；

##### 对于 `SELECT` 的逻辑

- 假设现在开启事务`A`事务`ID`为 100，在执行`SELECT k FROM T WHERE id = 1` 查到 `k = 10`；
- 这时候另一个客户端开始事务`B` 事务`ID`为101，执行更新 `UPDATE T SET k = k+1 WHERE id = 1`，然后提交事务：
  - 同时会把`DB_TRX_ID`更新为101，同时`undo log`保存`id=1,k=10`的回滚段，并把其指针保存在行记录中；
- 这时候事务`A`再执行`SELECT k`：
  - 先会找到`id=1`的记录，然后判断`DB_TRX_ID`比自己的事务`ID` 要大，则通过`DB_ROLL_PTR`找到上一个版本；
  - 在上一个版本中发现`DB_TRX_ID` 小于或等于自己的事务`ID`，则是自己需要找的值，返回`k=10`
- 在同一个事务中，两次找到的数据是一致的，这就是`MVCC`的快照功能，即快照读。

##### 对于 `UPDATE` 的逻辑

- 需要说明的是，在`MVCC`中，更新数据都是先读后写的，这个读，只能是读取当前的值，即当前读；
- 还是上面的场景，事务`A`在第二次`SELECT k` 后，进行 `UPDATE T SET k = k+1 WHERE id = 1`;
- 在更新时，当前读拿到的数据时 `k=11`，更新后`k=12`，并把当前事务`ID`记为`100`
  - 同时也因为事务`B`已经提交了，不会因为事务`B(TRX_ID=102)`比`事务A(TRX_ID=101)`而造成脏读问题；
- 这时候如果再次执行 `SELECT k` 时，因为最后一次修改的事务`ID`是事务`A`自己的，不会再去找`undo log`，返回`k=12`，逻辑无误。

##### 拓展：`InnoDB`向数据库中存储的每一行添加三个字段
- 6字节的`DB_TRX_ID`:标识插入或更新该行的最后一个事务的事务标识(删除被视为更新，行中的特殊位被设置位删除标记)
- 7字节的`DB_ROLL_PTR`:回滚指针，指向写入回滚端的`undo log`记录，回滚段包含重建之前行所需的内容
- 6字节的`DB_ROW_ID`：随着新行插入而单调增加的行`ID`，如果 `InnoDB`自动生成聚簇索引，则该索引包含行`ID`值。否则，该 `DB_ROW_ID`列不会出现在任何索引中

##### 拓展：当前读

- 概念
  - 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
- 当前读使用场景
  - `select lock in share mode`(共享锁)
  - `select for update`(排他锁)
  - `update、insert、delete`

##### 拓展：快照读

- 不加锁的 `select`操作就是快照读，即不加锁的非阻塞读；
- 当事务级别是串行级别下的快照读退化成为当前读；
- 快照读的实现是基于多版本并发控制(`MVCC`)，快照读可能读到的并不是数据的最新版本

------

### 数据库的读写分离的作用是什么？如何实现？

------

### 简述什么是两阶段提交？

------

### 简述 `MySQL` 的主从同步机制，如果同步失败会怎么样？

##### `MySQL`的主从同步机制

- 1-主库`A`接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写`binlog`;
- 2-在备库`B`上通过 `change master`命令，设置主库`A`的`IP`、端口、用户名、密码，以及要从哪个位置开始请求`binlog`，这个位置包含文件名和日志偏移量；
- 3-在备库`B`上执行`start slave`命令，这时候备库会启动两个线程，即`IO`线程和`SQL`线程，其中`IO`线程负责与主库建立连接；
- 4-主库`A`校验完用户名、密码后，开始按照备库`B`传过来的位置，从本地读取`binlog`，发给`B`；
- 5-备库`B`拿到`binlog`后，写到本地文件，这个文件称为中转日志(`relay log`)；
- 6-备库的`SQL`线程读取中转日志，解析出日志里的命令，并执行。

##### 拓展：`MySQL`主从复制模式

- 异步模式:默认模式，这种模式下，主节点不会主动 `push bin log`到从节点
  - 当从节点连接主节点时，会主动从主节点出获取最新的`bin log`文件；
  - 这种模式下可能导致`failover`(故障转移)，因为从节点没有即时将最新的`binlog`同步
  
- 半同步模式
  - 这种模式下主节点只需接收到其中一台从节点的返回信息，就会`commit`；
  - 否则需要等待直到超时时间，然后切换成异步模式再提交；
  - 可以时主从数据库的数据延迟缩小，提高安全性，性能上会有一定的降低，响应时间会变长
  
- 全同步模式
  - 主节点和从节点全部执行了`commit`并确认会给客户端返回成功

------

### 简述数据库中什么情况下进行分库，什么情况下进行分表？
