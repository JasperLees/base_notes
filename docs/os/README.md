## 进程与线程

### 进程和线程之间有什么区别？

- 一个线程只能属于一个进程，而一个进程可以由多个线程
- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存
- 进程是资源分配的最小单位，线程是`CPU`调度的最小单位
- 进程上下文切换比进程上下文切换要慢，开销大
- 进程间通信`IPC`，线程间可以直接读写进程数据段来进行通信(需要进程同步和互斥手段辅助，以保证数据的一致性)
  - `IPC`:进程数据交换通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间考到内核缓冲区，进程2再从内核缓冲区把数据读走
- 进程间不会互相影响，一个线程挂掉将导致整个进程挂掉

------

### 进程间有哪些通信方式？

- 进程间通信方式有7种，分别是：管道、`FIFO`、消息队列、信号量、共享内存、套接字(`socket`)、UNXI`域套接字

###### 管道

- 半双工，即不能同时在两个方向上传输数据，有的系统可能支持全双工
- 只能在父子进程间
  - 经典的形式就是管道由父进程创建，进程`fork`子进程后，就可以在父子进程直接使用
  
##### `FIFO`

- 与管道不同，不相关的进程也能够进行数据交换
- 用途：
  - 无需创建中间临时文件，复制输出流
  - 多客户-服务进程应用种，通过`FIFO`作为汇聚点，传输客户进程和服务进程之间的数据
  
##### 消息队列

- 消息链表，存储在内核种，进程可以从中读写数据；
- 与前两者的区别，进程可以在没有另外一个进程等待读的情况下进行写

##### 信号量

- 是一个计数器，主要用在多个进程需要对共享数据进行访问时；
- 检测该资源信号量，如果大于0，则资源可用，将其减1，表示使用；如果信号值为0，则进程休眠至信号值大于0

##### 共享内存

- 允许多个进程共享一个给定的存储区，但需要另外手段来保证共享内存的同步访问，如信号量

##### 套接字

- 利用网络进行通信，它能用于不同计算机之间的不同进程通信

##### `UNIX` 域套接字

- 和套接字相似，不需要执行协议处理
- 它只适合同一台计算机上的进程间通信

------

### 进程通信中的管道实现原理是什么？

------

### Linux 进程调度中有哪些常见算法以及策略？

- 常见的算法，非抢占的有先到先服务调度算法、最短作业算法；抢占的有最短剩余时间优先，轮转调度算法；还有最高优先级调度算法

##### 非抢占式进程调度算法

- 含义：直到该进程完成或发生某个事件发生而被阻塞时，才会把`CPU`让给其他进程
- 先到先服务(`FCFS`)调度算法
  - 按照进程到达的先后顺序进行调度
  - 优点：公平、算法简单
  - 缺点：对短进程不利
- 最短作业(进程)优先
  - 每次调度时选择当前已到达的、且运行时间最短的进程
  - 优点缺点和先到先服务相反
- 高响应比优先(`HRRN`)
  - 调度时计算所有就绪进程的响应比，为响应比最高的进程分配`CPU`
  - 响应比=(进程的等待时间+进程需要的运行时间)/进程需要的运行时间

##### 抢占式进程调度算法

- 可以被打断，把`CPU`让给其他进程
- 最短剩余时间优先(`SRTN`)：时间片原则
  - 是最短优先作业的抢占式版本
  - 当一个新的进程到达时，把它所需要的整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程
- 轮转调度算法(`RR`)/时间片调度算法：
  - 就绪队列中的每个进程轮流运行一个时间片(`10ms~200ms`)，当时间片耗尽时，就强迫当前运行进程让出`CPU`资源，转而排到就绪队列尾部，等待下一轮调度

##### 最高优先级调度算法(`HPF`)

- 从就绪队列中选择最高优先级的进程运行
  - 静态优先级：创建进程时，就预先规定优先级且不会发生变化(内核进程的优先级高于用户进程)
  - 动态优先级：随着就绪队列中进程的等待时间增加，适当的升高其优先级
- 系统可运行规则使用非抢占和抢占模式





##### 拓展：进程调度

- 就是从进程的就绪队列(阻塞)中按照一定的算法选择一个进程并将`CPU`分配给他运行，以实现进程的并发运行

##### 拓展：进程的三态模型

1. 运行态(`running`)：进程占有`CPU`正在运行
2. 就绪态(`ready`)：进行具备运行条件，等待系统分配`CPU`以便运行
3. 阻塞态/等待态(`wait`)：进程不具备运行条件，正在等待某个事件的完成

------

### 简单介绍进程调度的算法

------

### 进程有多少种状态？

------

### 线程有多少种状态，状态之间如何转换

------

### 线程间有哪些通信方式？

------

### 两个线程交替打印一个共享变量

------

### 什么情况下，进程会进行切换？

------

### 进程空间从高位到低位都有些什么？

------

## 多路复用(Redis)

### 简述 `socket` 中 `select、poll、epoll` 的使用场景以及区别，各自支持的最大描述符上限以及原因是什么？

##### 区别

- 这两者都是处理`IO`多路复用的编程手段
- `select/poll`模型是一种阻塞模型，`epoll`是非阻塞模型
- `select`最大描述符上限是1024，`poll/epoll`没有限制
- `select/poll`内部使用线程结构存储进程关注的`Socket`集合
  - 因此每次内核要判断某个消息是否发送给当前进程，`select/poll`需要遍历进程关注的`Socket`集合
- `epoll` 内部使用二叉搜索树(红黑树)，用`Socket`编号作为索引，用关注的时间类型作为值
  - 这样内核可用非常快的速度下就判断某个消息是否需要发送当前的线程

##### 使用场景


##### 各自支持最大描述符上限以及原因

- `Select`：最大描述符上限和系统内存有关，基于数组，32位机器1024，64位默认2048
- `poll`  ：没有最大连接数限制，因为它基于链表存储
- `epoll` : 没有最大连接的上限(`1G`的内存上能监听约10万个端口)

##### 拓展：概念

- `select`：监控三种文件描述符，读(`write_fds`)、写(`read_fds`)、异常(`except_fds`)
  - 调用后阻塞，直到有描述符就绪，或超时返回
- `poll`:查询每个`fd`对应的设备状态
  - 如果就绪，则加入等待队列，否则挂起等待
- `epoll`:通过`epoll_ctl`注册`fd`：
  - 一旦该`fd`就绪，内核就会采用类似`callback`的机制来激活`fd`, `epoll_wait`便可以收到通知

------

### `epoll` 中水平触发以及边缘触发有什么不同 

- 当`epoll_wait`检测到描述符事件发生此事件，通知应用程序时；
- 水平触发(`LT level trigger`)
  - 应用程序可以不立即处理该事件，下次调`epoll_wait时`，会再次响应应用程序并通知此事件
  - 默认模式
- 边缘触发(`ET edge trigger`)
  - 应用程序必须立即处理该事件，如果不处理，下次调用`epoll_wait`时，不会再次响应应用程序并通知此事件

------

### 简述同步与异步的区别，阻塞与非阻塞的区别

------

## 内存

### 操作系统如何申请以及管理内存的？

------

### 简述 Linux 零拷贝的原理

------

### 如何调试服务器内存占用过高的问题？

------

### 简述操作系统如何进行内存管理

------

### 操作系统如何申请以及管理内存的？

------

### 简述操作系统中 malloc 的实现原理

------

### Linux 中虚拟内存和物理内存有什么区别？有什么优点？

------

### 操作系统中，虚拟地址与物理地址之间如何映射？

------

### 简述操作系统中的缺页中断

------

## 应用

### 简述几个常用的 Linux 命令以及他们的功能。

------

### Linux 下如何排查 CPU 以及 内存占用过多？

------

### Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？

------

### Linux 如何查看实时的滚动日志？

------

### 简述 Linux 系统态与用户态，什么时候会进入系统态？

------

### 简述 LRU 算法及其实现方式

------

### 什么时候会由用户态陷入内核态？

------

### Linux 下如何查看端口被哪个进程占用？

------

### BIO、NIO 有什么区别？怎么判断写文件时 Buffer 已经写满？简述 Linux 的 IO模型

------

### 简述自旋锁与互斥锁的使用场景

------

### 简述 mmap 的使用场景以及原理

------

### 简述 traceroute 命令的原理

------
