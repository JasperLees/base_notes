### 快速排序的空间复杂度是多少？时间复杂度的最好最坏的情况是多少，有哪些优化方案？

##### 快速排序的时空复杂度

- Space: O(logn) 递归使用的空间
- BestTime: O(nlogn)
- WorstTime: O(n^2)，平均每次[遍历元素数+移动元素数] = n

##### 优化方案

- 优化1：三数取中位数(GO底层)
  - 取待排序的左端，中心位置，右端三个数比较，取中位数
    
- 优化2：当待排序序列的长度分割到一定大小后，使用插入排序
  - 对于很小和部分有序的数组，快排不如插排(最好O(n))
  - 截止范围：n = 12 (Go语言底层逻辑)
    
- 优化3：在一次分割结束后，可以把 value 相等的元素聚在一起，继续下次分割时，不用再对value相等元素分割(GO语言底层)
  - 例如：待排序nums=[5, 6, 7, 6, 6, 4, 6]，三数取中，nums[4] = 6
  - 转化后为： nums=[5, 6, 4, 6, 6, 7, 6]
  - 对相同value进行聚合,将相同的value转移到target的两端：nums=[5, 4, 6, 6, 6, 6, 7]，即剩余待排序为left=[5, 4], right=[7]
