# 算法

### 64 匹马，8 个赛道，找出前 4 匹马最少需要比几次；

- 分为8组，分别为`A1-A8 ... H1-H8`
- 跑 **8次**，保留每一组的前4名，分别为`A1-A4...H1-H4`
- 8组第一名(`A1-H1`)，跑**1次**，假设`A1`获取第一名,`B1`第二名,`C1`第三名,`D1`第四名，即确定第一名，
- 淘汰剩余四组，前四组也淘汰部分，剩余`A2-A4,B1-B3,C1-C2,D1`，九名
- 除了`A2`，其余8名，跑 **1次**， 如果`A3`在前三，则`A2`排名在`A3`前面，其他顺位往后，比赛结束
- 如果`A3`不在前三，则取前三名和`A2` 跑 **1次**，获得前三，比赛结束

##### 综上，最少跑 8+1+1=10次，最多11次一定能得出结果

------

### `AVL` 树和红黑树有什么区别

- `AVL`是高度平衡的二叉树，红黑树是近似平衡的二叉树
- 对于查询，`AVL`提供更快的查询，因为它是更严格的平衡
  - 查找树的时间复杂度为树的深度
  - `AVL`树的左右子树高度差必须满足小于2
  - 红黑树的左右子树的高度差小于两倍
- 对于插入和删除，红黑树提供了更快的插入和删除
  - `AVL`旋转的操作会更多
  - 红黑树旋转的操作相对较少
- 对于存储，两者都需要存储额外的信息，红黑对额外空间消耗更少
  - `AVL` 每个结点使用 `int` 来存储平衡因子或高度
  - 红黑树只需要使用  `bit` 来存储 0或1表示黑或红 
- 对于应用方向
  - 红黑树被应用对于大多数语言库的 `map` 或`set` 数据结构
  - `AVL` 被应用于检索更快的数据库中

##### `AVL`树的特点

- 左子树和右子树的高度差小于2
- 当两个子树的高度差大于1的时候进行重平衡整理

##### 红黑树的特点

- 具体来说，红黑树满足如下条件的二叉树
  - 每个结点要么是红色，要么是黑色
  - 根结点是黑色
  - 每个叶结点(`NIL`结点，空结点)是黑色的
  - 不能有相邻的两个红色结点
  - 从任何一个结点到其每个叶子的所有路径都包含相同数目的黑色结点
- 关键性质
  - 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

------

### 海量数据处理

#### 题型1：取出现最多的1个，内存有限制

- 解题思路：分治 + `HashMap` + 排序
- 分治：解决内存优先问题
  - 通过根据限制计算放置多少个合适(例如：`2^32`个`IP 4G 1024`个文件？)
  - 通过取模映射方法，可以把相同的的值放在同一个小文件中(`Hash(val)%1024`)
  - 如果单个文件还是超过内存限制，则可以再将单个文件分割
- `HashMap`：统计单个文件每个值出现的次数
- 排序：取各个文件最多出现次数的进行排序(次数排序，`map[次数]值`)

##### 题型进阶：取出现最多的N个，内存有限

- 采用题型1方法
- 不同的是，取出每个小文件最高的N个，然后进行归并排序

##### 题型进阶：大量数据中找出不重复的数，内存有限

- 采用：分治 + `HashMap` + 归并
- 分治：通过取模映射方法，可以把相同的的值放在同一个小文件中(`Hash(val)%1024`)
- `HashMap`: 删除重复元素，保留不重复元素
- 归并：再将小文件归并，删除重复元素，保留不重复元素

##### 题型进阶：两个大文件存`URL`，找到共同的`URL`，内存有限

- 采用：分治 + 文件比较
- 分治：分别通过取模方法(`Hash(val)%1000`)，将`a,b`文件分成小文件`a1...an, b1...bn`
- 因为是通过相关的取模方法，所以相同`URL`存放的文件标号也相同，所以比较`ak` 和 `bk`
- `ak-bk`相同的值进行归并就行

#### 题型2：取第`K`个最大的数

- 取第`k`个最大，使用最小堆
  - 取前`k`个数建堆，时间复杂度`O(klogk)`
  - 遍历所有数字，小于等于堆顶，`pass`，大于则替换堆顶元素，并调整为最小堆，时间复杂度`O(nklogk)`
  - 总体时间复杂度`O(nklogk)`

##### 题型进阶：内存限制

- 可以采用题型1方法，同时把每个文件的前`k`个值进行堆排序/归并排序

#### 题型3：海量不重复的`unsigned int`，判断一个数是否存在

- 使用位图法(`bit 1G = 8000000000 bit`)
  - 一个`bit`代表一个`int`值，读入数据进行占位，如果存在标记位1
  - 判断是，用这个数判断再`bit`位是否为1
  
#### 转换

- `1KB = 2^10 B 约 1000B `
- `1MB = 2^20 B 约 1百万B`
- `1GB = 2^30 B 约 10亿 B`
- `1GB = 80亿bit`

------

### `10`亿条数据包括 `id`，上线时间，下线时间，请绘制每一秒在线人数的曲线图

- 假设这10亿条数据是一天内的数据(也可以是一个月)，一天总共有`3600 * 24 = 86400`秒；
- 定义一个长度为 86400 的整数数组 `delta [86400]int`，每个整数对应这一秒的人数变化值，初始值为0；
- 然后一次读入每个用户的登录时间和退出时间，将与登录时间对应的整数值`+1`，将与退出时间对应的整数`-1`；
- 这样处理一遍后，数组中存储了每秒中的人数变化情况；
- 另外定义一个长度为 86400 的整数数组 `online [86400]int`，每个整数对应这一秒在线人数，初始值为0；
- 第1秒的人数为`online[0]=delta[0]`，第2秒的人数为`online[1]=online[0]+delta[1]`，一次类推，第`n`秒在线人数为 `online[n]=online[n-1]+delta[n]`;
- 这样就可以划出每一秒在线人数的曲线图

------

### 如何通过一个不均匀的硬币得到公平的结果？

- 这题的解法和：利用`Rand7()`实现`Rand10()` 类似

```go
// 连续抛两次硬币，得到的 (0,1)和(1,0)概率是相等的
// 则如果两次结果相同，重新抛，两次结果不同则说明公平

// 不均匀的硬币
func coin() int {
	// [0,3][4,9], 4:6
	if rand.Intn(10) > 4 {
		return 0
	} else {
		return 1
	}
}

// 两次结果不同，则表示概率相同，返回第一次抛的值
func coinResult() int {
	for {
		a := coin()
		if coin() != a {
			return a
		}
	}
}

func main()  {
	rand.Seed(time.Now().UnixNano())
	count := []int{0,0}
	for i := 0; i < 100000; i++ {
		count[coinResult()]++
	}
	fmt.Println(count)
}

```

