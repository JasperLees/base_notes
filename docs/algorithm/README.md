# 算法

### 64 匹马，8 个赛道，找出前 4 匹马最少需要比几次；

- 分为8组，分别为`A1-A8 ... H1-H8`
- 跑 **8次**，保留每一组的前4名，分别为`A1-A4...H1-H4`
- 8组第一名(`A1-H1`)，跑**1次**，假设`A1`获取第一名,`B1`第二名,`C1`第三名,`D1`第四名，即确定第一名，
- 淘汰剩余四组，前四组也淘汰部分，剩余`A2-A4,B1-B3,C1-C2,D1`，九名
- 除了`A2`，其余8名，跑 **1次**， 如果`A3`在前三，则`A2`排名在`A3`前面，其他顺位往后，比赛结束
- 如果`A3`不在前三，则取前三名和`A2` 跑 **1次**，获得前三，比赛结束

##### 综上，最少跑 8+1+1=10次，最多11次一定能得出结果

------

### `AVL` 树和红黑树有什么区别

- `AVL`是高度平衡的二叉树，红黑树是近似平衡的二叉树
- 对于查询，`AVL`提供更快的查询，因为它是更严格的平衡
  - 查找树的时间复杂度为树的深度
  - `AVL`树的左右子树高度差必须满足小于2
  - 红黑树的左右子树的高度差小于两倍
- 对于插入和删除，红黑树提供了更快的插入和删除
  - `AVL`旋转的操作会更多
  - 红黑树旋转的操作相对较少
- 对于存储，两者都需要存储额外的信息，红黑对额外空间消耗更少
  - `AVL` 每个结点使用 `int` 来存储平衡因子或高度
  - 红黑树只需要使用  `bit` 来存储 0或1表示黑或红 
- 对于应用方向
  - 红黑树被应用对于大多数语言库的 `map` 或`set` 数据结构
  - `AVL` 被应用于检索更快的数据库中

##### `AVL`树的特点

- 左子树和右子树的高度差小于2
- 当两个子树的高度差大于1的时候进行重平衡整理

##### 红黑树的特点

- 具体来说，红黑树满足如下条件的二叉树
  - 每个结点要么是红色，要么是黑色
  - 根结点是黑色
  - 每个叶结点(`NIL`结点，空结点)是黑色的
  - 不能有相邻的两个红色结点
  - 从任何一个结点到其每个叶子的所有路径都包含相同数目的黑色结点
- 关键性质
  - 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

------

### 快速排序

```go
func main() {
	nums := []int{5, 2, 7, 4, 6, 3, 8, 1, 0, 9}
	quickSort(nums, 0, len(nums)-1)
	fmt.Println(nums)
}

func quickSort(nums []int, start, end int) {
	if start >= end {
		return
	}
	target := nums[end] // 去start 先找右边，取end先找左边
	left, right := start, end
	for left < right {
		// 找到从前往后的第一个比 target 大的 index
		for left < right && nums[left] <= target {
			left++
		}
		// 找到从后往前的第一个比 target 小的 index
		for left < right && nums[right] >= target {
			right--
		}
		// 交互
		nums[left], nums[right] = nums[right], nums[left]
	}
	// 找到target最终放的位置，交互target(end位) 和 nums[left]
	nums[end], nums[left] = nums[left], target
	// 递归排序 target 左右两边的数组
	quickSort(nums, start, left-1)
	quickSort(nums, left+1, end)
}
```

------

### 10亿个数中如何高效地找到最大的一个数以及最大的第 `K` 个数

- 方法一：快速排序，取 `topk`

- 方法二：局部淘汰法
  - 维护一个长度 `K` 的数组 `arr`，先取前 `K` 个数放入数组，对该数组进行升序排序；
  - 再取后续的元素和 `arr[0]` 相比，如果比 `arr[0]` 小，直接 `pass`；
  - 如果比 `arr[0]` 大，则丢弃 `arr[0]`，再利用二分查找找到其位置，该位置前的数组整体向前移动；
  - 源数据读取解锁，数组 `arr` 为 `top K`
  - 时间复杂度:`O(n + k^2)`

- 方法三： `Hash`法(计算排序)
  - 因为10亿个数里面会有很多重复的数，先通过 `map` 把各数出现次数记录下来;
  - 然后通过最小堆，对 `key` 进行排序，然后根据各个 `key` 的个数，取出`top k`

- 方法四：最小堆
  - 先读入前`K`个数来创建大小为 `K`的最小堆，建堆的时间复杂度为 `O(klogk)`；
  - 然后遍历后续的数字， 和堆顶(最小)数字进行比较。如果比较最小的数字小，则继续读取后续数字；
  - 如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆；
  - 遍历完成，按中序遍历方式，删除堆中的 `K` 个数字；
  - 时间复杂度为 `O(nmlog)`
  
##### 拓展：找重复率高的前 `top k`

- `Hash`计算+基于计数的最小堆

------

### `10`亿条数据包括 `id`，上线时间，下线时间，请绘制每一秒在线人数的曲线图

- 假设这10亿条数据是一天内的数据(也可以是一个月)，一天总共有`3600 * 24 = 86400`秒；
- 定义一个长度为 86400 的整数数组 `delta [86400]int`，每个整数对应这一秒的人数变化值，初始值为0；
- 然后一次读入每个用户的登录时间和退出时间，将与登录时间对应的整数值`+1`，将与退出时间对应的整数`-1`；
- 这样处理一遍后，数组中存储了每秒中的人数变化情况；
- 另外定义一个长度为 86400 的整数数组 `online [86400]int`，每个整数对应这一秒在线人数，初始值为0；
- 第1秒的人数为`online[0]=delta[0]`，第2秒的人数为`online[1]=online[0]+delta[1]`，一次类推，第`n`秒在线人数为 `online[n]=online[n-1]+delta[n]`;
- 这样就可以划出每一秒在线人数的曲线图

------

### 如何通过一个不均匀的硬币得到公平的结果？

- 这题的解法和：利用`Rand7()`实现`Rand10()` 类似

```go
// 连续抛两次硬币，得到的 (0,1)和(1,0)概率是相等的
// 则如果两次结果相同，重新抛，两次结果不同则说明公平

// 不均匀的硬币
func coin() int {
	// [0,3][4,9], 4:6
	if rand.Intn(10) > 4 {
		return 0
	} else {
		return 1
	}
}

// 两次结果不同，则表示概率相同，返回第一次抛的值
func coinResult() int {
	for {
		a := coin()
		if coin() != a {
			return a
		}
	}
}

func main()  {
	rand.Seed(time.Now().UnixNano())
	count := []int{0,0}
	for i := 0; i < 100000; i++ {
		count[coinResult()]++
	}
	fmt.Println(count)
}

```
