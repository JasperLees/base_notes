## 算法

### 64 匹马，8 个赛道，找出前 4 匹马最少需要比几次；

- 分为8组，分别为`A1-A8 ... H1-H8`
- 跑 **8次**，保留每一组的前4名，分别为`A1-A4...H1-H4`
- 8组第一名(`A1-H1`)，跑**1次**，假设`A1`获取第一名,`B1`第二名,`C1`第三名,`D1`第四名，即确定第一名，
- 淘汰剩余四组，前四组也淘汰部分，剩余`A2-A4,B1-B3,C1-C2,D1`，九名
- 除了`A2`，其余8名，跑 **1次**， 如果`A3`在前三，则`A2`排名在`A3`前面，其他顺位往后，比赛结束
- 如果`A3`不在前三，则取前三名和`A2` 跑 **1次**，获得前三，比赛结束

##### 综上，最少跑 8+1+1=10次，最多11次一定能得出结果

------

### `AVL` 树和红黑树有什么区别

- `AVL`是高度平衡的二叉树，红黑树是近似平衡的二叉树
- 对于查询，`AVL`提供更快的查询，因为它是更严格的平衡
  - 查找树的时间复杂度为树的深度
  - `AVL`树的左右子树高度差必须满足小于2
  - 红黑树的左右子树的高度差小于两倍
- 对于插入和删除，红黑树提供了更快的插入和删除
  - `AVL`旋转的操作会更多
  - 红黑树旋转的操作相对较少
- 对于存储，两者都需要存储额外的信息，红黑对额外空间消耗更少
  - `AVL` 每个结点使用 `int` 来存储平衡因子或高度
  - 红黑树只需要使用  `bit` 来存储 0或1表示黑或红 
- 对于应用方向
  - 红黑树被应用对于大多数语言库的 `map` 或`set` 数据结构
  - `AVL` 被应用于检索更快的数据库中

##### 红黑树的特点

- 具体来说，红黑树满足如下条件的二叉树
  - 每个结点要么是红色，要么是黑色
  - 根结点是黑色
  - 每个叶结点(`NIL`结点，空结点)是黑色的
  - 不能有相邻的两个红色结点
  - 从任何一个结点到其每个叶子的所有路径都包含相同数目的黑色结点
- 关键性质
  - 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

------

## 快速排序

```go
func main() {
	nums := []int{5, 2, 7, 4, 6, 3, 8, 1, 0, 9}
	quickSort(nums, 0, len(nums)-1)
	fmt.Println(nums)
}

func quickSort(nums []int, start, end int) {
	if start >= end {
		return
	}
	target := nums[end] // 去start 先找右边，取end先找左边
	left, right := start, end
	for left < right {
		// 找到从前往后的第一个比 target 大的 index
		for left < right && nums[left] <= target {
			left++
		}
		// 找到从后往前的第一个比 target 小的 index
		for left < right && nums[right] >= target {
			right--
		}
		// 交互
		nums[left], nums[right] = nums[right], nums[left]
	}
	// 找到target最终放的位置，交互target(end位) 和 nums[left]
	nums[end], nums[left] = nums[left], target
	// 递归排序 target 左右两边的数组
	quickSort(nums, start, left-1)
	quickSort(nums, left+1, end)
}
```

------

### 10亿个数中如何高效地找到最大的一个数以及最大的第 `K` 个数

- 方法一：快速排序，取 `topk`

- 方法二：局部淘汰法
  - 维护一个长度 `K` 的数组 `arr`，先取前 `K` 个数放入数组，对该数组进行升序排序；
  - 再取后续的元素和 `arr[0]` 相比，如果比 `arr[0]` 小，直接 `pass`；
  - 如果比 `arr[0]` 大，则丢弃 `arr[0]`，再利用二分查找找到其位置，该位置前的数组整体向前移动；
  - 源数据读取解锁，数组 `arr` 为 `top K`
  - 时间复杂度:`O(n + k^2)`

- 方法三： `Hash`法(计算排序)
  - 因为10亿个数里面会有很多重复的数，先通过 `map` 把各数出现次数记录下来;
  - 然后通过最小堆，对 `key` 进行排序，然后根据各个 `key` 的个数，取出`top k`

- 方法四：最小堆
  - 先读入前`K`个数来创建大小为 `K`的最小堆，建堆的时间复杂度为 `O(klogk)`；
  - 然后遍历后续的数字， 和堆顶(最小)数字进行比较。如果比较最小的数字小，则继续读取后续数字；
  - 如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆；
  - 遍历完成，按中序遍历方式，删除堆中的 `K` 个数字；
  - 时间复杂度为 `O(nmlog)`
  
##### 拓展：找重复率高的前 `top k`

- `Hash`计算+基于计数的最小堆

##### 拓展：[`go`版最小堆](./go最小堆.md)

------
