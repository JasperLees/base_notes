## 算法

### 64 匹马，8 个赛道，找出前 4 匹马最少需要比几次；

- 分为8组，分别为`A1-A8 ... H1-H8`
- 跑 **8次**，保留每一组的前4名，分别为`A1-A4...H1-H4`
- 8组第一名(`A1-H1`)，跑**1次**，假设`A1`获取第一名,`B1`第二名,`C1`第三名,`D1`第四名，即确定第一名，
- 淘汰剩余四组，前四组也淘汰部分，剩余`A2-A4,B1-B3,C1-C2,D1`，九名
- 除了`A2`，其余8名，跑 **1次**， 如果`A3`在前三，则`A2`排名在`A3`前面，其他顺位往后，比赛结束
- 如果`A3`不在前三，则取前三名和`A2` 跑 **1次**，获得前三，比赛结束

##### 综上，最少跑 8+1+1=10次，最多11次一定能得出结果

### `AVL` 树和红黑树有什么区别

- `AVL`是高度平衡的二叉树，红黑树是近似平衡的二叉树
- 对于查询，`AVL`提供更快的查询，因为它是更严格的平衡
  - 查找树的时间复杂度为树的深度
  - `AVL`树的左右子树高度差必须满足小于2
  - 红黑树的左右子树的高度差小于两倍
- 对于插入和删除，红黑树提供了更快的插入和删除
  - `AVL`旋转的操作会更多
  - 红黑树旋转的操作相对较少
- 对于存储，两者都需要存储额外的信息，红黑对额外空间消耗更少
  - `AVL` 每个结点使用 `int` 来存储平衡因子或高度
  - 红黑树只需要使用  `bit` 来存储 0或1表示黑或红 
- 对于应用方向
  - 红黑树被应用对于大多数语言库的 `map` 或`set` 数据结构
  - `AVL` 被应用于检索更快的数据库中

#### 红黑树的特点

- 具体来说，红黑树满足如下条件的二叉树
  - 每个结点要么是红色，要么是黑色
  - 根结点是黑色
  - 每个叶结点(`NIL`结点，空结点)是黑色的
  - 不能有相邻的两个红色结点
  - 从任何一个结点到其每个叶子的所有路径都包含相同数目的黑色结点
- 关键性质
  - 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长
