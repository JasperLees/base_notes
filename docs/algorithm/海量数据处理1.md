
### 海量数据处理

#### 题型1：取出现最多的1个，内存有限制

- 解题思路：分治 + `HashMap` + 排序
- 分治：解决内存优先问题
  - 通过根据限制计算放置多少个合适(例如：`2^32`个`IP 4G 1024`个文件？)
  - 通过取模映射方法，可以把相同的的值放在同一个小文件中(`Hash(val)%1024`)
  - 如果单个文件还是超过内存限制，则可以再将单个文件分割
- `HashMap`：统计单个文件每个值出现的次数
- 排序：取各个文件最多出现次数的进行排序(次数排序，`map[次数]值`)
- 优点：简单，而且内置排序可以排序超过内存的数据
- 缺点：对文件读写比较多

##### 题型进阶：取出现最多的N个，内存有限

- 采用题型1方法
- 不同的是，取出每个小文件最高的N个，然后进行归并排序

##### 题型进阶：大量数据中找出不重复的数，内存有限

- 采用：分治 + `HashMap` + 归并
- 分治：通过取模映射方法，可以把相同的的值放在同一个小文件中(`Hash(val)%1024`)
- `HashMap`: 删除重复元素，保留不重复元素
- 归并：再将小文件归并，删除重复元素，保留不重复元素

##### 题型进阶：两个大文件存`URL`，找到共同的`URL`，内存有限

- 采用：分治 + 文件比较
- 分治：分别通过取模方法(`Hash(val)%1000`)，将`a,b`文件分成小文件`a1...an, b1...bn`
- 因为是通过相关的取模方法，所以相同`URL`存放的文件标号也相同，所以比较`ak` 和 `bk`
- `ak-bk`相同的值进行归并就行

#### 题型2：取第`K`个最大的数

- 取第`k`个最大，使用最小堆
  - 取前`k`个数建堆，时间复杂度`O(klogk)`
  - 遍历所有数字，小于等于堆顶，`pass`，大于则替换堆顶元素，并调整为最小堆，时间复杂度`O(nklogk)`
  - 总体时间复杂度`O(nklogk)`

##### 题型进阶：内存限制

- 可以采用题型1方法，同时把每个文件的前`k`个值进行堆排序/归并排序

#### 题型3：海量不重复的`unsigned int`，判断一个数是否存在

- 使用位图法(`bit 1G = 8000000000 bit`)
  - 一个`bit`代表一个`int`值，读入数据进行占位，如果存在标记位1
  - 判断是，用这个数判断再`bit`位是否为1
  
#### 转换

- `1KB = 2^10 B 约 1000B `
- `1MB = 2^20 B 约 1百万B`
- `1GB = 2^30 B 约 10亿 B`
- `1GB = 80亿bit`
