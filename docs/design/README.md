# 消息队列

### 如何设计一个消息队列

------

### 设计一个阻塞队列

------

### kafka 如何保证消息一致性？

------

### Kafka 发送消息是如何保证可靠性的？

------

# 线程

### 如何设计一个线程池

------

### 高并发情景下，核心线程池该如何设置参数？

------

# 设计模式

### 什么是设计模式，描述几个常用的设计模式

##### 概念

- 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
- 使用设计模式是为了可重用代码、让代码容易被他人理解、 保证代码可靠性、程序的重用性。

##### 观察者模式

- 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。又称发布-订阅模式
- 优点：
  - 降低目标与观察者之间的耦合关系
- 缺点：
  - 目标与观察者之间的依赖关系并没有完全解除，而且可能会出现循环引用
  - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

##### 单例模式

- 指一个类只有一个实例，且该类能自行创建这个实例的，对外提供一个访问该单例的全局访问点

##### 工厂模式

- 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体的子工厂累当中。满足了创建与使用相分离

------

### 简述生产消费者模式的流程

------

# 负载

### 什么是 `CAP` ？什么是最终一致性？什么是幂等操作？

#### 什么是`CAP`

- `C`：代表一致性，`A`：代表可用性，`P`：代表分区容错性
- 分布式系统不可能同时满足这三项，最多只能同时满足其中两项
- 一致性：所有节点在同一时间具有相同的数据
- 可用性：保证每个请求不管成功或者失败都有响应
- 分区容错性：系统中任意信息的丢失或失败不会影响系统的继续运作

##### 权衡

- 在分布式系统中，一致性和可用性不可能同时程利，因为通信可能失败，即出现分区容错；
- 因此`CAP`理论实际上是要在一致性和可用性之间做选择；
- 一致性和可用性往往是冲突的，很难使它们同时满足。
- 在多个节点之间进行数据同步时：
  - 为了保证一致性(`CP`)，不能访问未同步完成的节点，也就是失去部分可用性
  - 为了保证可用性(`AP`)，允许读取所有节点的数据，但是数据可能不一致

#### 最终一致性(`BASE`)

- 最终一致性基于`BASE`理论，它是对`CAP`中一致性和可用性权衡的结果；
- 它的核心思想是：即使无法做到强一致性，但每个应用都可用根据自身业务特点，采用适当的方式来使系统达到最终一致性
- `BASE`是基本可用(`Basically Available`)、软状态(`Soft State`)和最终一致性(`Eventually Consistent`)三个短语的缩写

##### 基本可用

- 指分布式系统在出现故障时，保证核心可用，允许损失部分可用性

##### 软状态

- 指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性
- 即允许系统不同节点的数据副本之间进行同步的过程存在时延

##### 最终一致性

- 是指在系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态

##### `ACID`与`BASE`

- `ACID`要求强一致性，通常运用在传统的数据库系统上；
- `BASE`要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中；
- 在实际的分布式场景中，不同业务单元和组件对一致性的要求不同的，因此`ACID`和`BASE`往往会结合在一起使用

#### 幂等操作

- 幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。即不论执行多少次，产生的效果和返回的结果都是一样的

------

## 简述 Zookeeper 基础原理以及使用场景

------
### ZooKeeper 的 ZAB 算法与 Paxos 的区别是什么？

------
### 几种常见的限流算法

#### 1.计数器算法

##### 核心思想

- 对于某个接口，一段固定时间窗口内的请求进行计数；
- 如果请求数超过阈值，则舍弃请求；如果没有达到设定的阈值，则接受该请求，计数器+1；
- 当窗口时间结束，重置计数器；

##### 优点

- 容易实现

##### 缺点

- 窗口切换可能会产生两倍于阈值流量的请求；
- 例如:设置某接口每分钟只能有100个请求，一个恶意的用户，他在 10:59 瞬间发送100个请，并且11：00 又瞬间发送了100个请求；
- 用户可能通过这个漏洞，瞬间压垮为我们的应用；

#### 2.计数器滑动窗口算法

- 是固定窗口的升级版，将时间窗口分为多个小窗口，每个小窗口维护独立的计算器，所有小窗口计数器的总和不能超过大窗口的阈值；
- 移动时，左边的小窗口数据丢弃，将新加入的放入最右边，依次类推
- 这种方法解决了两倍阈值流量的问题；

#### 3. 漏斗算法

- 请求来到时，会先进入漏斗里，然后漏斗以恒定的速率将请求流出去，从而起到平滑流量的作用；
- 当请求的流量过大时，漏斗达到最大容量时会溢出，此时请求被丢弃；
- 从系统来看，请求永远是以平滑的传输速率过来的，从而起到保护系统的作用；

##### 缺点

- 无法解决流量突发问题

#### 4.令牌桶算法

- 对漏斗算法的改进，处理可以起到匀速限流，还可以允许一定程度的流量突发。
- 算法中，存在一个令牌桶，以恒定的速率向令牌桶放入令牌。令牌桶也有一定的容量，如果满了令牌就无法放进去了；
- 当请求来时，会首先到令牌桶取拿令牌，如果拿到了令牌，则该请求会被处理，并消耗拿到的令牌；如果令牌桶为空，则该请求会被丢弃。

------

### 布隆过滤器原理



------

## 应用

### 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？

- 秒杀活动分为3个阶段：秒杀前，秒杀中，秒杀后

##### 秒杀前-前端

- 缓存：对于秒杀商品详情页，尽量将能静态化的元素静态处理，除了秒杀按钮需要服务端进行动态判断，其他的静态数据可以缓存在浏览器和`CDN`上
- 禁用：活动开始前端需要限制用户请求秒杀接口

##### 秒杀前-后端

- 动态签名
  - 为了防止别人通过下单页面`URL`去直接访问后台秒杀商品，需要在秒杀接口增加动态签名
  - 活动开始时通过`MD5`加密一串随机字符最为签名，如果前端请求的签名不正确，直接丢弃
- 数据库设计
  - 秒杀有把我们的服务器击垮的风险，将秒杀功能数据库独立出来，避免牵连其他服务器
- 单`Redis`升级为集群`Redis`
  - 考虑到缓存雪崩问题，我们应该构建`Redis`集群，采用哨兵模式，可以提升`Redis`的性能和可用性
- 缓存预热
  - 将秒杀的商品库存加载到`Redis`中，`SET goodsId count`

##### 秒杀中-前端

- 限流：可以考虑对秒杀按钮加一个冷却时间，或同一个用户`10S`内重复请求直接拒绝

##### 秒杀中-后端

- 抢夺购买资格

  - 通过`Lua`脚本实现，当`goodsId count>0`时，获得一次购买资格，`Redis`是单线程模型，`Lua`可以保证多个命令的原子性，防止超卖
  - 如果每获得资格，直接返回

  ```lua
  local goodsId = tonumber(ARGV[1])
  if not goodsId or goodsId <= 0 then
  	return 0
  end
  
  local val = redis.call("GET", goodsId)
  if not val or val <= 0 then
  	return
  end
  redis.call("DECR", goodsId)
  return 1
  ```

- 异步下单
  
  - 为了提升下单效率，降低数据库压力，将获取到资格的用户保存到消息队列中，异步处理订单入库
- 生成订单
  
  - 在生成订单，并更新数据库库存的过程中，使用`WHERE count > 0`作为乐观锁，同样也是为了防止超卖
- 超时取消
  
  - 下单完成，使用`Redis zset`实现延时队列，订单`ID`为`member`，超时时间戳为`score`，维护一个当前时间戳的窗口，窗口之前的数据，判断如果没有支付，则订单失败
- 增加库存
  
  - 对于下单失败、超时取消、主动取消的购买资格，应该通过增加库存把它加回来，同时也需要判断不能超过总库存，这也是防止超卖的一种手段

##### 秒杀后-后端

- 当库存秒杀完毕，订单全部生成，需要检查订单量和总库存是否一致，如果不一致则需要增加`Redis`的库存
- 这是为了方式在下单失败、超时取消、主动取消时，`Redis`更新失败导致库存总量变少

------

### 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？

------

### 停车场有有限个车位，有多个车来抢车位，设计一个系统需要根据车辆进入和离开停车场的时间进行计费

------

# 其他

### 简述 Git 的工作流

------
#### 简述 MapReduce 的原理

------

#### 如何解决缓存与数据库不一致的问题？

- 普通情况下，使用旁路缓存策略，能解决绝大多数的问题

##### 旁路缓存策略(`Cache Aside`)

- 读的时候，先读缓存，缓存不存在，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后删除缓存

- 为什么是删除缓存，不是更新缓存？
  - 缓存可能是由多个表数据组成的，每更新一次要查询所有表数据的代价比较大
  - 如果在更新比较频繁的场景，往往缓存数据还没被使用，新的更新数据已经到来

##### 存在的问题

- 如果在更新数据库成功，但是删除缓存失败的情况下，会造成数据不一致
- 可以使用重试机制进行缓存删除，或者对缓存策略进行变种

##### 旁路缓存策略变种

- 读取逻辑不变
- 更新逻辑
  - 1. 先删除缓存
  - 2. 更新数据，如果此时更新失败，`MySQL`数据回滚，其他线程再来读取数据时，也是查到最新的数据
  - 3. 休眠一段时间(例如：500ms)，再次删除`Redis`数据。这么做的目的是为了防止，再完成删除缓存且未开始更新数据库的时间，其他线程过来读取更新前的数据进行缓存，造成数据不一致
  
##### 拓展：其他缓存策略

- 读写穿透缓存策略(`Read/Write Through`)

  - 写：缓存不存在更新数据库，缓存存在，更新缓存和数据库
  - 读：读入数据库，如果缓存不存在，则用缓存服务加载，写入缓存并返回
  - 优点：存储服务负责数据读写，隔离性更佳，对热数据友好
  - 缺点：`Redis`不支持自动从`MySQL`获取，除非增加逻辑
  
- 异步缓存写入策略(`Write Behind`)

  - 写：只更新缓存，缓存服务异步更新数据库
  - 读：如果缓存不存在，由缓存
  - 优点：写性能高，适合写频率高的情况
  - 缺点：定期异步刷新，存在数据丢失的概率
