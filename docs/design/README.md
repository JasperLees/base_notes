# 消息队列

### 如何设计一个消息队列

------

### 设计一个阻塞队列

------

### kafka 如何保证消息一致性？

------

### Kafka 发送消息是如何保证可靠性的？

------

# 线程

### 如何设计一个线程池

------

### 高并发情景下，核心线程池该如何设置参数？

------

# 设计模式

### 什么是设计模式，描述几个常用的设计模式

##### 概念

- 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
- 使用设计模式是为了可重用代码、让代码容易被他人理解、 保证代码可靠性、程序的重用性。

##### 观察者模式

- 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。又称发布-订阅模式
- 优点：
  - 降低目标与观察者之间的耦合关系
- 缺点：
  - 目标与观察者之间的依赖关系并没有完全解除，而且可能会出现循环引用
  - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

##### 单例模式

- 指一个类只有一个实例，且该类能自行创建这个实例的，对外提供一个访问该单例的全局访问点

##### 工厂模式

- 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体的子工厂累当中。满足了创建与使用相分离

------

### 简述生产消费者模式的流程

------

# 负载

### 简述常见的负载均衡算法

------

### 什么是 `CAP` ？什么是最终一致性？什么是幂等操作？

#### 什么是`CAP`

- `C`：代表一致性，`A`：代表可用性，`P`：代表分区容错性
- 分布式系统不可能同时满足这三项，最多只能同时满足其中两项

##### 一致性

- 一致性指的是多个数据副本是否能保持一致的特性
- 在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态
- 对系统的一个数据更新成功后，



------

## 简述 Zookeeper 基础原理以及使用场景

------
### ZooKeeper 的 ZAB 算法与 Paxos 的区别是什么？

------
### 几种常见的限流算法

#### 1.计数器算法

##### 核心思想

- 对于某个接口，一段固定时间窗口内的请求进行计数；
- 如果请求数超过阈值，则舍弃请求；如果没有达到设定的阈值，则接受该请求，计数器+1；
- 当窗口时间结束，重置计数器；

##### 优点

- 容易实现

##### 缺点

- 窗口切换可能会产生两倍于阈值流量的请求；
- 例如:设置某接口每分钟只能有100个请求，一个恶意的用户，他在 10:59 瞬间发送100个请，并且11：00 又瞬间发送了100个请求；
- 用户可能通过这个漏洞，瞬间压垮为我们的应用；

#### 2.计数器滑动窗口算法

- 是固定窗口的升级版，将时间窗口分为多个小窗口，每个小窗口维护独立的计算器，所有小窗口计数器的总和不能超过大窗口的阈值；
- 移动时，左边的小窗口数据丢弃，将新加入的放入最右边，依次类推
- 这种方法解决了两倍阈值流量的问题；

#### 3. 漏斗算法

- 请求来到时，会先进入漏斗里，然后漏斗以恒定的速率将请求流出去，从而起到平滑流量的作用；
- 当请求的流量过大时，漏斗达到最大容量时会溢出，此时请求被丢弃；
- 从系统来看，请求永远是以平滑的传输速率过来的，从而起到保护系统的作用；

##### 缺点

- 无法解决流量突发问题

#### 4.令牌桶算法

- 对漏斗算法的改进，处理可以起到匀速限流，还可以允许一定程度的流量突发。
- 算法中，存在一个令牌桶，以恒定的速率向令牌桶放入令牌。令牌桶也有一定的容量，如果满了令牌就无法放进去了；
- 当请求来时，会首先到令牌桶取拿令牌，如果拿到了令牌，则该请求会被处理，并消耗拿到的令牌；如果令牌桶为空，则该请求会被丢弃。

------

### 布隆过滤器原理



------

## 应用

### 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？

- 秒杀活动分为3个阶段：秒杀前，秒杀中，秒杀后

##### 秒杀前-前端

- 缓存：对于秒杀商品详情页，尽量将能静态化的元素静态处理，除了秒杀按钮需要服务端进行动态判断，其他的静态数据可以缓存在浏览器和`CDN`上
- 禁用：活动开始前端需要限制用户请求秒杀接口

##### 秒杀前-后端

- 动态签名
  - 为了防止别人通过下单页面`URL`去直接访问后台秒杀商品，需要在秒杀接口增加动态签名
  - 活动开始时通过`MD5`加密一串随机字符最为签名，如果前端请求的签名不正确，直接丢弃
- 数据库设计
  - 秒杀有把我们的服务器击垮的风险，将秒杀功能数据库独立出来，避免牵连其他服务器
- 单`Redis`升级为集群`Redis`
  - 考虑到缓存雪崩问题，我们应该构建`Redis`集群，采用哨兵模式，可以提升`Redis`的性能和可用性
- 缓存预热
  - 将秒杀的商品库存加载到`Redis`中，`SET goodsId count`

##### 秒杀中-前端

- 限流：可以考虑对秒杀按钮加一个冷却时间，或同一个用户`10S`内重复请求直接拒绝

##### 秒杀中-后端

- 抢夺购买资格

  - 通过`Lua`脚本实现，当`goodsId count>0`时，获得一次购买资格，`Redis`是单线程模型，`Lua`可以保证多个命令的原子性，防止超卖
  - 如果每获得资格，直接返回

  ```lua
  local goodsId = tonumber(ARGV[1])
  if not goodsId or goodsId <= 0 then
  	return 0
  end
  
  local val = redis.call("GET", goodsId)
  if not val or val <= 0 then
  	return
  end
  redis.call("DECR", goodsId)
  return 1
  ```

- 异步下单
  - 为了提升下单效率，降低数据库压力，将获取到资格的用户保存到消息队列中，异步处理订单入库
- 生成订单
  - 在生成订单，并更新数据库库存的过程中，使用`WHERE count > 0`作为乐观锁，同样也是为了防止超卖
- 超时取消
  - 下单完成，使用`Redis zset`实现延时队列，订单`ID`为`member`，超时时间戳为`score`，维护一个当前时间戳的窗口，窗口之前的数据，判断如果没有支付，则订单失败
- 增加库存
  - 对于下单失败、超时取消、主动取消的购买资格，应该通过增加库存把它加回来，同时也需要判断不能超过总库存，这也是防止超卖的一种手段

##### 秒杀后-后端

- 当库存秒杀完毕，订单全部生成，需要检查订单量和总库存是否一致，如果不一致则需要增加`Redis`的库存
- 这是为了方式在下单失败、超时取消、主动取消时，`Redis`更新失败导致库存总量变少

------

### 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？

------

### 停车场有有限个车位，有多个车来抢车位，设计一个系统需要根据车辆进入和离开停车场的时间进行计费

------

# 其他

### 简述 Git 的工作流

------
#### 简述 MapReduce 的原理

------
