
# 调度

### 简述 `Go` 调度流程 7

### `GMP`模型好处 9

### 协程和进程和线程的区别？2

### `Go` 里面一个协程能保证绑定在一个内核线程上吗？2

### `Go` 的协程可以不可以自己主动让出 `CPU` 2

### 简述 `Go` 协程通信方式有哪些？2

### 简述 `Go` 伪抢占式调度 2

### 简述什么是`goroutine`泄漏？1

### `Goroutine` 什么时候会被挂起(1)

- 在向无缓冲且没有接收者的`Channel`，或缓冲区已满的`Channel`写入数据时，`Goroutine`会挂起
- 在向无缓冲且发送者的`Channel`，或缓冲区已空的`Channel`读取数据时，`Goroutine`会挂起
TODO


# `GC`

### 简述 `Go` 垃圾回收的流程 5

### 两次 `GC` 周期重叠会引发什么问题，`GC` 触发机制是什么样的？4

### 内存逃逸

# 数据结构

### `Go` 是如何实现 `map` 5





##### 拓展：拉链法

- 实现拉链法一般使用链表+数组
- 写入数据：先通过哈希函数对键进行哈希，得到一个数组的`index`，然后判断该数组位置的链表中是否存在该键，如果存在则更新数据，否则在链表末尾追加新的键值对

##### 拓展：开放寻址法：

- 核心思想：依次探测和比较数组中的元素，以判断目标键值对是否存在于哈希表中
- 写入数据：当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置
- 查找数据：先获取键的哈希并取模，然后找到对应位置，判断该位置的键和目标是否一致，不一致就会继续查找后面的元素，直到内存为空或者找到目标元素

### `Map`是线程安全的吗？怎么解决并发安全问题？2

### 简述 `defer` 的特性，及 `defer` 的执行顺序 4

- `Go`语言的`defer`会在当前函数返回前，执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源

##### `defer`中主要有两个特性

  - 后调用的`defer` 函数会先执行

    - `Go`语言的编译器会将`defer`转换成`runtime.deferproc`，还会在调用`defer`的函数结尾插入`runtime.deferreturn`；
    - `runtime.deferproc` 会为`defer`创建一个新的`runtime._defer`结构体，并将它追加到所在`Goroutine _defer` 链表的最前面
    - `runtime.deferreturn`会从`Goroutine` 的`_defer`链表中取出最前面的`runtime._derfer` 进行处理

- 函数的参数会被预先计算

  - 调用`runtime.deferproc`函数创建新的延迟调用时，就会立刻拷贝参数，函数的参数不会等到真正执行时计算

  ```go
  func main() {
  	for i := 0; i < 3; i++ {
  		defer fmt.Println(i) // 输出：2,1,0，因为i是延迟函数的参数，被拷贝了
  		defer func() {
  			fmt.Println(i)     // 输出：3,3,3,因为此时的i属于外部函数，没有被拷贝
  		}()
  	}
  }
  ```

##### 拓展：为什么`recover`只能在`defer`中，才能终止`panic` 造成的程序崩溃？

```go
func main() {
	defer fmt.Println("in main") // 会被打印
	if err := recover(); err != nil {
  	fmt.Println(err)           // 不会被打印
  }
  panic("unknown err")
}
```

- 在`Go`语言中，将`panic`和 `recover` 分别转换为`runtime.gopanic`和`runtime.gorecover`
- 在运行过程中遇到`runtime.gopanic`方法时，主要操作是：
  - 创建新的`runtime._painc`结构体，并添加到所在`Goroutine`的`_painc`链表的最前端；
  - 为了保证一些收尾工作能安全完成，会从所在`Goroutine`的 `_defer`中依次取出延迟函数进行处理；
  - 然后判断当前`runtime._painc`结构体中的`recovered`值，如果为`true`则调用`runtime.recovery`，进行错误处理并恢复到正常的执行流程，如果为`flase`则调用`fatalpanic`终止程序
- 在运行过程中遇到`runtime.gorecover`方法时，主要是将所在`Goroutine`的`_panic`链表第一个`runtime._panic`的`recovered`值设为`true`
- 所以说，如果不将`recover`函数包在`defer`中，发生`panic`时则无法被调用到，也无法设置`runtime._panic recovered = true`，`panic`就会导致程序崩溃。

### `slice` 的底层原理，`slice` 和数组的区别是什么？3

- `Slice`的底层主要是包括：一个指向底层数组的指针、切片的长度`len`、底层数组的容量`cap`；
- `Slice`作为参数传递是值传递，因为他的值包含了底层数组的指针，所以被调用的函数修改切片值时，是同一指针指向的数组被修改，原切片会受影响；但是如果在追加元素时，因为原切片的固定长度不会发生变化，所以原切片不会改变。这就是我们写 `arr = append(arr, 1)`时为什么要用把结果赋值给原变量；
- 使用`append` 进行追加时，我们会先从切片中获取它的数组指针、大小和容量，如果追加元素后切片的大小大于容量，则需要扩容，在分配内存空间前，需要确定新的切片容量：
  - 如果期望容量大于当前容量的两倍，则使用期望容量，否则进行下一步处理；
  - 如果当前切片的长度小于1024，则将容量翻倍，否则进行一下步处理；
  - 不符合上述两点，通过每次给增加`25%`的容量，直到新容量大于期望容量

##### `slice`和数组的区别

- `Go`语言数组在初始化后大小无法改变，所以创建时必须指定数组的大小
- `Go`语言的切片是动态数组，长度并不固定，可以向切片追加元素，它会在容量不足时自动扩容。

### 有缓存的管道和没有缓存的管道区别 3

- `Go` 中有缓冲和无缓冲的 `Channel`区别是，有缓冲的是同步，无缓冲的是异步
- 打个比方，邮差送信
    - 无缓冲的管道，邮差送信到你家门口，如果你不在家，他不走，你一定要接下信，他才会走；
      - 也就是无缓冲的`Channel`必须有接收值，否则会阻塞；
    - 有缓冲的管道，邮差送信到你家，直接把信放到信箱中，就可以走了，如果你的信箱满了，他需要等待信箱腾出位置才能走；
      - 也就是有缓冲的`Channel`如果有空闲，可以把数据写入，然后处理结束；
      - 如果缓冲区被写满，则`Goroutine`被阻塞，需要等待缓冲区腾出位置被它写入，处理才算完成。

### `channel` 怎么实现线程安全

```go
type hchan struct {
	buf      unsafe.Pointer // 保存数队列
	sendx    uint           // 发送数据位置
	recvx    uint           // 接收数据位置
	recvq    waitq          // 等待接收的Goroutine队列
	sendq    waitq          // 等待写入的Goroutine队列
	lock mutex
}
```

- `Channel`在运行时的内部表示是`runtime.hchan`，该结构体中包含了用于保护成员变量的互斥锁，从某种程度上说，`Channel`是一个用于同步和通信的有锁队列；
- 同时`runtime.hchan`有一个循环队列(`buf`)、读取和写入队列的标记位`sendx`(`send index`)和`recv`(`receive index`)，用于数据的循环写入和顺序写入；
- `runtime.hchan`有发送队列(`sendq`)和接收队列(`recvx`)，使得数据的发送和接收的先进先出(`FIFO`)，提供了安全性；

##### `Channel`收发数据

- 当读`Gorotine G1`向`Channel`发送数据时，首先需要获取锁，拿到锁，发送数据可能会发生下面3种情况：
  - 1-如果当前`Channel`的`recvq`上存在已经被阻塞的`Goroutine`，将数据发送给队列的第一个接收者,并将其设置下一个运行的`Goroutine`；
  - 2-如果`Channel`存在缓冲区且有空闲的容量，则会直接将数据存储到缓冲区，`sendx`所在的位置上；
  - 3-如果不满足上面的两种情况，，则会挂起当前`Goroutine`，并将它加入`sendq`队列末尾；
- 处理完上述三种情况后，释放锁；

- 当`G2`读取`Channel`的数据时，先获取锁，拿到锁后，接收数据可能会发送下面4中种情况：
  - 1-如果`Channel`为`nil`，那么会直接调用`runtime.gopark`挂起当前`Goroutine`；
  - 2-如果`Channel`已经关闭并且缓冲区没有任何数据，会直接返回；
  - 3-如果`Channel`的缓冲区中包含数据，那么直接读取`recvx`索引对应的数据；
    - 接收完后判断`sendq`是否有挂起的`Goroutine`；
    - 如果有则将`sendq`队列中第一个`Goroutine`的数据拷贝到缓冲区；
  - 4-如果当前缓冲区没有数据，则会挂起当前`Goroutine`，并将它加入`recvq`队列末尾
- 处理完上面情况后，释放锁。

### `make`和`new` 的区别

- `make`的作用是创建切片、哈希表和`Channel`等内置的数据结构
- `new`的作用是为类型申请一块内存空间，并返回指向这块内存的指针

# 其他

### `Go` 有哪些优缺点、错误处理有什么优缺点？4

### 平时写`go`，怎么调试的？有做过`test`和`benchmark`吗？1


