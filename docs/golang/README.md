
# 调度

### 简述 `Go` 调度流程 7

##### GMP含义

- G:代表Goroutine，指一个待执行的任务
- M：操作系统的线程，由操作系统调度和管理
- P：处理器或者调度器

##### GMP的关系

- 关系1：在GMP中，管理这G有两种队列，一是全局队列，二是调度器P维护的队列
- 关系2：G必须在M上运行，所以一个M必须持有一个P，它们的比例近似1：1

##### 调度场景

- 场景1：我们通过 go func(){} 创建Goroutine时：
  - 新创建的 Goroutine 会被先放入当前线程绑定的P管理的Goroutine队列中；
  - 如果队列的容量超过了256个，则会将队列中一半的Goroutine转移到全局队列中
- 场景2：如果当前线程从P管理队列中获取待执行的G，且队列为空时：
  - 会先去全局队列中拿一部分的Goroutine放到P管理的队列中(n=len(GQ)/ GOMAXPROCS+1)；
  - 如果全局队列为空，则会随机的从P列表中选择一个P，窃取它的Goroutine队列的一半的G
- 场景3：当线程上执行的Goroutine发生系统调度或其他阻塞操作时，线程会阻塞：
  - 如果线程上的P还有待执行的Goroutine，runtime将把P从线程上摘除；
  - 再创建或者复用一个空闲的线程，来服务这个P
- 场景4：当M系统调用结束时：
  - 会尝试去获取一个空闲的P，如果获取到，则将之前执行的Goroutine放入这个P维护的队列中；
  - 如果获取不到，则将该线程变成休眠状态，加入空闲线程中，然后把G放入到全局队列中

##### 拓展：有关概念

- 全局队列：存放等待运行的`G`
- `P`的本地队列：同全局队列类似，存放的也是等待运行的`G`，存的数据量有限：
  - 不超过`256`个。
- `P`列表(`P`的数量)：所有的`P`都再程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`个
- `M`的数量：`Go`语言启动时，会设置`M`的最大数量，默认`10000`。一个`M`阻塞了，会创建新的`M`(或者复用)
- 自旋线程：如果`M`没有`G`可执行，`M`处于自旋状态，它会不断寻找`Goroutine`
  - 最多`GOMAXPROCS`个自旋的线程，多余的会让他们休眠

##### 拓展：`P`和`M`何时被创建
- `P`：在确定`P`的最大数量`n`后，运行时系统会根据这个数量创建`n`个`P`
- `M`：没有足够的`M`来关联`P`并运行其中可运行的`G`
  - 比如所有的`M`此时都阻塞了，而`P`中还有很多就绪任务，就会去寻找空闲的`M`，没有空闲的，就会去创建新的`M`

##### 拓展：特殊的`M0`和`G0`

- `M0`
  - 是启动程序后的编号为0的主线程，这个`M`对应的实例会在全局变量`runtime.m0`中；
  - 不需要在堆(`heap`)上分配，`M0`复杂执行初始化操作和启动第一个`G`，之后`M0`就和其他的`M`一样了

- `G0`
  - `G0`是每次启动一个`M`都会第一个创建的`Goroutine`,`G0`仅用于负责调度`G`；
  - `G0`不指向任何可执行的函数，每个`M`都会有一个自己的`G0`；
  - 在调度或系统调用是会使用`G0`的栈空间，全局变量的`G0`属于`M0`
  
##### 拓展：可视化`GMP`

- `go tool trace`
- `Debug trace`

------

### `GMP`模型好处 9

- `GMP`的好处有：负载均衡、复用线程、减少阻塞、利用并行
- 负载均衡
  - 如果当前的`MP`组合创建了很多的`G`，会将一半的`G`移动到全局队列，减轻当前线程负担；
- 复用线程：避免频繁的创建、销毁线程，而是对线程的复用
  - 当本线程无可执行的`G`时，尝试从其他线程绑定的`P`窃取`G`，而不是销毁线程
- 减少阻塞：使用抢占式调度器
  - 当本线程因为`G`进行系统调用阻塞时，线程释放绑定的`P`，把`P`转移给其他空闲的线程执行
- 利用并行
  - `GOMAXPROS`设置`P`的数量，最多有`GOMAXPROCS`个线程分布在多个`CPU`上同时运行。

##### 拓展：并行与并发

- 你吃饭吃到一半，电话来了，你停下来接了电话，接完后继续吃饭，说明支持并发
- 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，说明支持并行
- 区别在于：是否是同时

------

### 协程和进程和线程的区别？2

##### `goroutine`和线程的区别

- 可增长的栈
  - `OS`线程(操作系统线程)一般固定的栈内存，通常为`2MB`
  - 一个 `goroutine` 的栈在生命周期开始时，只有`2KB`，`goroutine` 的栈不是固定的，按需增大和缩小，大小限制可以达到 `1GB`
- 创建与销毁的开销更小
  - 线程创建需要向操作系统申请资源，在销毁时将资源归还，开销比较大
  - `goroutine` 的创建和销毁是由 `go` 语言在运行时自己管理的，开销小
- 切换开销小
  - `go` 能实现高并发的主要原因
  - 线程的调度方式是抢占式的
    - 如果一个线程的执行时间超过分配的时间片，就会被其他可执行的线程抢占
    - 切换过程中需要保存/恢复所有的寄存信息
  - `goroutine` 的调度是协作式抢占
    - 不会直接地与操作系统内核打交道，没有时间片概念
    - 会在下面几个时间点对其进行切换
      - `Channel` 接收或者发送会造成阻塞的消息
      - 当一个新的 `goroutine` 被创建时
      - 可以造成阻塞的系统调用，如文件和网络操作
      - 垃圾回收
- `Goroutine`没有`ID`号，线程都有一个独特的身份(`ID`)

------

### `Go` 里面一个协程能保证绑定在一个内核线程上吗？2

- 不能，原因有3
- 1-`GMP`模型中，`P`本地队列中，`Goroutine`的个数不能超过`256`个：
  - 所以当新建的`Goroutine`假如一个已经满的`P`队列时，`P`会把本地队列一半的`G`移动到全局队列；
  - 而其他线程绑定的`P`在本地队列为空时，会从全局队列中取可执行的`G`取处理，所以不能保证；
- 2-`GMP`模型中，当`P`的队列为空且全局队列也为空时，此时`P`会从`MP`组合窃取一半的可执行`G`，所以不能保证；
- 3-`GMP`模型中，当`G`进入系统调用时，对应的`M`和`P`阻塞在系统调度中，线程释放绑定的`P`，会使用空闲线程或重新创建一个线程来服务器于`P`，所以不能保证

------

### `Go` 的协程可以不可以自己主动让出 `CPU` 2

- 可以
- 如果`Gorotinue`在处理`channel`读写条件不满足，就会调用`runtime.gopark` 将自己挂起，让出`CPU`；
- 调用`runtime.Gosched `,可以主动让出处理器，运行其他`Goroutine`运行
  - 该函数无法挂起`Goroutine`，调度器可能会将当前`Goroutine`调度到其他线程上 

##### `runtime.gopark`主要做的事

- 解除当前`Goroutine`的`MP`绑定关系，将当前`Goroutine`状态切换为等待状态；
- 调用一次`runtime.schedule()`函数，在`P`发起一轮新的调度

------

### 简述 `Go` 协程通信方式有哪些？2

- `Channel`
  - `Goroutine`之间最主要的同时方式，是支撑`Go`语言高性能并发编程模型的重要结构
- 上下文`Context`
  - 主要作用是在多个 `Goroutine`组成的树中同步取消信号，以减少对资源的消耗和占用
  - 虽然它也有传值功能，但是这个功能很少用到
- `WaitGroup`
  - 使用了信号量，用于控制并发
  - `wg.Add(1)`表示将内部计数器的待启动`Goroutine`增加1
  - `wg.Done()`表示`Goroutine`执行完成，计数器减1
  - `wg.Wait()` 方法阻塞当前`Goroutine`直到计数器变为0，才被唤醒
- `Mutex`锁
  - 保证多个`Goroutine`在访问同一片内存时不会通信竞争条件等问题

###### 拓展：`Go`中除了`Mutex`锁外，还有哪些方式安全读写的共享变量

- `Goroutine`可以通过`Channel`进行安全读写共享变量

------

### 简述 `Go` 伪抢占式调度 2

- 在`Go 1.4`版本之前，`Go`是基于协作的抢占式的调度，也就是伪抢占式调度，而从`1.14`版本实现了基于信号的真抢占式调度
- 基于协作式的调度
  - 编译器会在调用函数前插入扩容栈(`runtime.morestack`)的逻辑；
  - `Go`语言运行时会在垃圾回收暂停程序、系统监控发现`Goroutine`运行时超过`10ms` 时，在该`Goroutine`设置一个抢占标记(`g.stackguard0=StackPreempt`)；
  - 当发生函数调用时，会执行栈扩容（`runtime.morestack`）逻辑，检查到抢占的标记为后，就会触发抢占，让出当前线程；
  - 所以，当一个`Goroutine`内部没有函数调用时，该`Goroutine`不会让出线程，其他的`Goroutine`无法被处理，这就是伪抢占式调度；
- 基于信号的抢占式调度
  - 在程序启动时，在`runtime`中注册信号的处理函数(`sighandler`)；
  - 在触发垃圾回收的栈扫描时，将运行中的`Goroutine`标记成可以被抢占，然后向`M`发送信号
  - `M`接收到信号后，会让当前`Goroutine`陷入休眠继续执行其他的`Goroutine`

------

### 简述什么是`Goroutine`泄漏？1

##### 概念

- 如果你启动一个`Goroutine`，但并没有符合预期的退出，直到程序结束，此`Goroutine`才退出，这种情况就是`Goroutine`泄漏

###### 导致的问题

- 当`Goroutine`泄漏发送时，该`Goroutine`的栈(一般`2k`内存空间起)一直被占用不能释放；
- `Goroutine`里面的函数在堆申请的空间也不能被垃圾回收器回收；
- 这样，在程序运行期间，内存占用持续升高，可用内存越来越少，最终导致系统崩溃

###### 拓展：`Goroutine`泄漏的场景

- `Goroutine`泄漏一般是因为`Channel`操作阻塞而导致整个`Goroutine`一直阻塞等待或者`Goroutine`里面有死循环

##### `Goroutine`泄漏检测和定位

- 使用`Go`提供的`pprof`工具分析是否发生内存泄漏；
- 使用`pprof`的`heap`能够获取程序运行时的内存信息，通过对运行的程序多次采样对比，分析内存的使用情况；

##### 拓展：`Goroutine`泄漏的防范

- 创建`Goroutine`时要想好，`Goroutine`该如何结束
- 使用`Channel`，要考虑到`Channel`阻塞时协程可能的行为
- 实现循环语句时要注意循环的退出条件，避免死循环

------

### `Goroutine` 什么时候会被挂起(1)

- `channel`读写条件不满足 
  - 在向无缓冲且没有接收者的`Channel`，或缓冲区已满的`Channel`写入数据时，`Goroutine`会挂起
  - 在向无缓冲且发送者的`Channel`，或缓冲区已空的`Channel`读取数据时，`Goroutine`会挂起
- 系统调用时会挂起`Goroutine`
- 在触发垃圾回收的栈扫描时，会挂起`Goroutine`

------

# `GC`

### 简述 `Go` 垃圾回收的流程 5

- 阶段1:标记阶段
  - 1-1 暂停程序，将状态切换至GC标记状态，开启写屏障、用户程序协助(辅助GC)，并将根对象加入灰色队列
  - 1-2 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记为灰色，所有新创建的对象都会被直接标记成黑色
  - 1-3 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
  - 1-4 灰色队列为空，标记完成，进入标记终止阶段
- 阶段2:清理阶段
  - 1-2:暂停程序，关闭辅助标记的用户程序、关闭写屏障

- `Golang`的垃圾回收机制主要通过三色标记清除和写屏障来保证`GC`的高效；
- 在启动`GC`的时候先`STW`，启动相关的标记协程，开启写屏障，然后再恢复运行。此时用户程序与标记程序同时运行；
- 当标记程序完成时，再次`STW`，此时就清理`GC`相关的数据与信息，并启动回收协程，关闭写屏障，然后再次恢复运行；
- 此时垃圾回收与用户程序同时运行，从而完成一次垃圾回收；
- 通过现在这种机制，大幅提高了垃圾回收的响应效率，减少了`STW`对用户程序的影响

##### `STW(Stop The World)`

- `Golang` 中的`STW`就是停掉所有的`Goroutine`，专心做垃圾回收，待垃圾回收结束后再恢复`Goroutine`

##### 写屏障(`Write Barries`)

- 写屏障是后台并发标记的重要补充。在非`STW`状态下执行标记，必然会出现已经扫描过的对象又引用了新的对象的情况，这时新对象就没有被标记；
- 写屏障解决了这个问题。
- 写屏障打开后，对指针的修改操作会将指针的新旧值全部加入`GC`工作队列。并在并发标记完成后再进入`STW`，最后检查一次`GC`工作队列，保证所有对象都在最新状态扫描标记过。
- 最新版的`Golang`使用复合写屏障技术，避免了在最后阶段需要从根节点开始重新扫描一遍的工作。

##### 辅助`GC`(`Mutator Assist`)

- 为了防止内存分配过快，在`GC`执行过程中，如果`Goroutine`需要分配内存，那么这个`Goroutine`会参与一部分`GC`的工作，即帮助`GC`做一部分工作

##### 三色标记清除

- 三色分别：
  - 白色：没有被引用的对象
  - 灰色：被引用的对象，但还没分析他是否引用其他对象
  - 黑色：被引用的对象，且已经分析了他是否引用了其他对象
- 具体逻辑：
  - 1：将所有对象标记为白色
  - 2：将根对象标记为灰色，并加入待处理队列
  - 3：从待处理队列中取出一个对象，标记为黑色，并将这个对象引用的所有白色对象都标记为灰色，并加入待处理队列
  - 4: 循环指向第3步，直到待处理队列为空，不存在灰色对象为止
  - 5：灰色所有白色对象

------

### 两次 `GC` 周期重叠会引发什么问题，`GC` 触发机制是什么样的？4

##### 两次 `GC` 周期重叠会引发什么问题

- GC一共有三个阶段，GC标记、GC标记终止、GC终止
- 当第二次GC是在GC标记或GC标记制止的阶段时，都会被直接返回，不能往下执行
- 当第二次GC是在GC终止阶段出发的，假如还存在未被清理的内存，必须先清理完后，才能进入标记阶段


##### `GC`启动的三种情况

- 后台触发
  - 会在后台开启一个强制触发垃圾收集的`Gorotine`，默认每2分钟，进行一次检查和垃圾收集
- 手动触发
  - 通过`runtime.GC`这个函数手动触发
- 申请内存
  - 当前线程的内存管理单元不存在空闲空间是，需要申请新的内存时，可能触发垃圾收集； 

------

### 内存逃逸

TODO

------

# 数据结构

### `Go` 是如何实现 `map` 5

```go
type hmap struct {
    count   int  // 当前保存的元素个数
    B       uint8 // 2^B表示 bucket 数组的大小
    buckets unsafe.Pointer // bucket 数据的指针
}

type bmap struct {
    tophash [8]uint8 // 存储哈希值的高8位
    data    byte[1]  // 虚拟字段，通过指针和偏移量计算出来，key val数据：key/key/.../val/val/...
    overflow *bmap   // 虚拟字段，通过指针和偏移量计算出来， 溢出 bucket 地址
}
```

- `Go`的`Map`是通过拉链法进行实现的，其底层的数据结构是 `hmap`
  - 包含字段`buckets`数组和`B`，数组的长度是`2^B`，数组的元素一个哈希桶(`bucket`), 其底层数据结构是`bmap`
- 每一个桶都是一整块的内存空间
  - 最开始保存一个长度为8的`tophash`数组，存储哈希值的高8；
  - 除了数组外，通过指针和偏移依次保存数组的高位哈希对应的真实哈希和值；
  - 其存储形式是 `key0/key1/.../key7/val0/val1/.../val7`；
  - 当一个桶存超过8个`key`后，会另外创建一个新的桶，也就是溢出桶，存储溢出的`key-value`，并将其地址指针保存在`val7`后面；
- 当我们读取数据时：
  - 通过哈希函数获取当前键对应的哈希，再通过内部函数(`runtime.bucketMask`和`runtime.add`)获取桶序号和高8位的哈希值；
  - 通过桶序号可以迅速找到数据应该存放的桶的位置；
  - 通过遍历`tophash`取查找高8位哈希是否存在，如果存在则在通过指针和偏移量取出对应的`key`，如果一致，则返回相关的值；
  - 如果不在`tophash`数组或`key`不一致，则会通过溢出桶取寻找下一个批高位哈希，直到没有下一个溢出桶为止。
  
##### 拓展：扩容

- 扩容条件
  - 负载因子 `> 6.5`时 (键值对数 / `bucket`数)
  - 溢出桶(`overflow`) `> 2^15(32768)` 个
  
- 逐步搬迁策略
  - 扩大一倍的桶，创建新的桶数组，并没有迁移数据
  - 只有在赋值和删除的过程才出触发，每次迁移两个桶
  
- 等量扩容
  - `buckets`数量不变，重新做一遍类似增量扩容的变迁动作，把松散的键值对重新排列一次

##### 拓展：桶大小

- 键值堆占据的内存空间大小只能在编译是进行推导

##### 拓展：拉链法

- 实现拉链法一般使用链表+数组
- 写入数据：先通过哈希函数对键进行哈希，得到一个数组的`index`，然后判断该数组位置的链表中是否存在该键，如果存在则更新数据，否则在链表末尾追加新的键值对

##### 拓展：开放寻址法：

- 核心思想：依次探测和比较数组中的元素，以判断目标键值对是否存在于哈希表中
- 写入数据：当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置
- 查找数据：先获取键的哈希并取模，然后找到对应位置，判断该位置的键和目标是否一致，不一致就会继续查找后面的元素，直到内存为空或者找到目标元素

------

### `Map`是线程安全的吗？怎么解决并发安全问题？2

- `Map`不是线程安全的；
- 解决方法：
  - 通过读写锁(`sync.RWMutex`)实现对`map`的并发访问

------

### 简述 `defer` 的特性，及 `defer` 的执行顺序 4

- `Go`语言的`defer`会在当前函数返回前，执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源

##### `defer`中主要有两个特性

  - 后调用的`defer` 函数会先执行

    - `Go`语言的编译器会将`defer`转换成`runtime.deferproc`，还会在调用`defer`的函数结尾插入`runtime.deferreturn`；
    - `runtime.deferproc` 会为`defer`创建一个新的`runtime._defer`结构体，并将它追加到所在`Goroutine _defer` 链表的最前面
    - `runtime.deferreturn`会从`Goroutine` 的`_defer`链表中取出最前面的`runtime._derfer` 进行处理

- 函数的参数会被预先计算

  - 调用`runtime.deferproc`函数创建新的延迟调用时，就会立刻拷贝参数，函数的参数不会等到真正执行时计算

  ```go
  func main() {
  	for i := 0; i < 3; i++ {
  		defer fmt.Println(i) // 输出：2,1,0，因为i是延迟函数的参数，被拷贝了
  		defer func() {
  			fmt.Println(i)     // 输出：3,3,3,因为此时的i属于外部函数，没有被拷贝
  		}()
  	}
  }
  ```

##### 拓展：为什么`recover`只能在`defer`中，才能终止`panic` 造成的程序崩溃？

```go
func main() {
	defer fmt.Println("in main") // 会被打印
	if err := recover(); err != nil {
  	fmt.Println(err)           // 不会被打印
  }
  panic("unknown err")
}
```

- 在`Go`语言中，将`panic`和 `recover` 分别转换为`runtime.gopanic`和`runtime.gorecover`
- 在运行过程中遇到`runtime.gopanic`方法时，主要操作是：
  - 创建新的`runtime._painc`结构体，并添加到所在`Goroutine`的`_painc`链表的最前端；
  - 为了保证一些收尾工作能安全完成，会从所在`Goroutine`的 `_defer`中依次取出延迟函数进行处理；
  - 然后判断当前`runtime._painc`结构体中的`recovered`值，如果为`true`则调用`runtime.recovery`，进行错误处理并恢复到正常的执行流程，如果为`flase`则调用`fatalpanic`终止程序
- 在运行过程中遇到`runtime.gorecover`方法时，主要是将所在`Goroutine`的`_panic`链表第一个`runtime._panic`的`recovered`值设为`true`
- 所以说，如果不将`recover`函数包在`defer`中，发生`panic`时则无法被调用到，也无法设置`runtime._panic recovered = true`，`panic`就会导致程序崩溃。

------

### `slice` 的底层原理，`slice` 和数组的区别是什么？3

- `Slice`的底层主要是包括：一个指向底层数组的指针、切片的长度`len`、底层数组的容量`cap`；
- `Slice`作为参数传递是值传递，因为他的值包含了底层数组的指针，所以被调用的函数修改切片值时，是同一指针指向的数组被修改，原切片会受影响；但是如果在追加元素时，因为原切片的固定长度不会发生变化，所以原切片不会改变。这就是我们写 `arr = append(arr, 1)`时为什么要用把结果赋值给原变量；
- 使用`append` 进行追加时，我们会先从切片中获取它的数组指针、大小和容量，如果追加元素后切片的大小大于容量，则需要扩容，在分配内存空间前，需要确定新的切片容量：
  - 如果期望容量大于当前容量的两倍，则使用期望容量，否则进行下一步处理；
  - 如果当前切片的长度小于1024，则将容量翻倍，否则进行一下步处理；
  - 不符合上述两点，通过每次给增加`25%`的容量，直到新容量大于期望容量

##### `slice`和数组的区别

- `Go`语言数组在初始化后大小无法改变，所以创建时必须指定数组的大小
- `Go`语言的切片是动态数组，长度并不固定，可以向切片追加元素，它会在容量不足时自动扩容。

------

### 有缓存的管道和没有缓存的管道区别 3

- `Go` 中有缓冲和无缓冲的 `Channel`区别是，有缓冲的是同步，无缓冲的是异步
- 打个比方，邮差送信
    - 无缓冲的管道，邮差送信到你家门口，如果你不在家，他不走，你一定要接下信，他才会走；
      - 也就是无缓冲的`Channel`必须有接收值，否则会阻塞；
    - 有缓冲的管道，邮差送信到你家，直接把信放到信箱中，就可以走了，如果你的信箱满了，他需要等待信箱腾出位置才能走；
      - 也就是有缓冲的`Channel`如果有空闲，可以把数据写入，然后处理结束；
      - 如果缓冲区被写满，则`Goroutine`被阻塞，需要等待缓冲区腾出位置被它写入，处理才算完成。

------

### `channel` 怎么实现线程安全

```go
type hchan struct {
	buf      unsafe.Pointer // 保存数队列
	sendx    uint           // 发送数据位置
	recvx    uint           // 接收数据位置
	recvq    waitq          // 等待接收的Goroutine队列
	sendq    waitq          // 等待写入的Goroutine队列
	lock mutex
}
```

- `Channel`在运行时的内部表示是`runtime.hchan`，该结构体中包含了用于保护成员变量的互斥锁，从某种程度上说，`Channel`是一个用于同步和通信的有锁队列；
- 同时`runtime.hchan`有一个循环队列(`buf`)、读取和写入队列的标记位`sendx`(`send index`)和`recv`(`receive index`)，用于数据的循环写入和顺序写入；
- `runtime.hchan`有发送队列(`sendq`)和接收队列(`recvx`)，使得数据的发送和接收的先进先出(`FIFO`)，提供了安全性；

##### `Channel`收发数据

- 当读`Gorotine G1`向`Channel`发送数据时，首先需要获取锁，拿到锁，发送数据可能会发生下面3种情况：
  - 1-如果当前`Channel`的`recvq`上存在已经被阻塞的`Goroutine`，将数据直接拷贝到接收变量上(`x = <-c`)，将等待接收数据的`Goroutine` 标记成可运行状态发送方的调度器在下一次调度时会立即唤醒数据的接收放(放在`runnext`上等待执行)
  - 2-如果`Channel`存在缓冲区且有空闲的容量，则会直接将数据存储到缓冲区，`sendx`所在的位置上；
  - 3-如果不满足上面的两种情况，，则会挂起当前`Goroutine`，并将它加入`sendq`队列末尾；
- 处理完上述三种情况后，释放锁；

- 当`G2`读取`Channel`的数据时，先获取锁，拿到锁后，接收数据可能会发送下面4中种情况：
  - 1-如果`Channel`为`nil`，那么会直接调用`runtime.gopark`挂起当前`Goroutine`；
  - 2-如果`Channel`已经关闭并且缓冲区没有任何数据，会直接返回；
  - 3-如果`Channel`的缓冲区中包含数据，那么直接读取`recvx`索引对应的数据；
    - 接收完后判断`sendq`是否有挂起的`Goroutine`；
    - 如果有则将`sendq`队列中第一个`Goroutine`的数据拷贝到缓冲区；
  - 4-如果当前缓冲区没有数据，则会挂起当前`Goroutine`，并将它加入`recvq`队列末尾
- 处理完上面情况后，释放锁。

###### 拓展：`CSP`与`Channel`

- `CSP`是以通信的方式共享数据
- 用于描述两个独立的并发实体通过共享的通讯`Channel`进行通信的并发模型

------

### `make`和`new` 的区别

##### 作用的对象

- `new`是值类型和用户定义的类型
- `make`是内置引用类型`map`、`slice`、`channel`

##### 返回值

- `new`用来分配内存，并初始化零值，返回零值指针
  - 如果该对象申请的空间为0，则返回表示空指针的`zerobase`变量
  - 其他情况，则开辟一块内存空间，返回对应的地址
- `make`为更加复杂的数据结构开辟内存空间，并对一些字段进行初始化，返回引用类型本身

##### 可以用`new` 去初始化`map、slice、channel`吗

- `map`：`new`没有对`map`做创建桶等初始化操作，所以添加键值对时会`panice`，查询和删除不存在`key`时，因为没有对应的桶，查询返回零值，删除不作操作，不会`panic`
- `channel`：没有对`channel`的缓冲区开辟内存空间，以及更多的内部初始化操作，`channel`始终是`nil`，往里面发送或从里面接收数据都会引发`panic`
- `slice`：可以正常使用，因为切片在`append`时会申请一块内存，返回一个新的切片

------

### `fallthrough`

- `Go`中的`switch`默认相当于每个`case`最后都带有`break`，匹配成功不会自动向下执行其他`case`，而是跳出整个`switch`
- 使用`fallthrough`，可以强制执行后面的`case`代码

------

# 其他

### `Go` 有哪些优缺点、错误处理有什么优缺点？4

##### 优点

- 自动垃圾回收降低了开发难度
- 丰富的内置类型(`Map, Slice`)
- 支持函数多返回值
- 简洁的错误处理
  - `Go`引入`defer`关键字用于标准的错误处理流程;
  - 并内置函数`panic`、`recover`完成异常的抛出与捕获；
  - 相比`Java`，更简洁
- 并发编程更轻盈更安全
  - `Go` 引入`Goroutine`，比线程更加轻盈、更省资源的协程；
  - 通过使用`Channel`通信，使用消息传递来共享内存，使并发编程更加安全
  
##### 缺点

- 缺少框架
- 软件包管理

------

### 平时写`go`，怎么调试的？有做过`test`和`benchmark`吗？1

- 通过功能测试(`Test`)与性能测试(`Benchmark`)进行调试

#### `go test`要点

##### 文件和函数命名

- 文件必须要`*_test.go`
- 功能测试函数名必须以`Test`开头，函数参数必须是 `*testing.T`
- 性能测试函数名必须以`Benchmark`开头，函数参数必须是`*testing.B`

##### 测试过程

- 功能测试，`go test`会并发执行，默认最大是8个并发，可以通过`-parallel`指定
- 性能测试，`go test -bench=.`，性能测试中控制循环调用的次数是`b.N`控制的
  - 测试每个函数时如果运行时间没有超过`1s`，那么就会调大`b.N`重新测试，直到达到`1s`
  - 结果展示的就是此时的`b.N`值和平均每次耗时

##### 执行模式与`Cache`

- 两种执行模式

- `local mode`：即直接`cd`到特定目录中运行 `go test`，不用指定目录，无`cache`功能

- `package list mode`：

  - 在任意目录中运行 `go test`，指定测试的`package`目录

  - 测试成功后测试会被`cache`，如果没有改动过测试函数与被测试函数，则直接使用`cache`结果加速整个测试

  - `go clean -cache` 清除所有测试

##### `Log`

  - `t.Error/Errof`测试失败，输出错误日志
  - `tFatal/Fatalf`测试失败，输出错误日志，立即退出后续测试


- 控制循环调用的次数，测试每个函数时如果运行时间没有超过

------

### 选项模式

- `Golang`的开发者提供了将一个函数的参数设置为可选的功能，也就是说我们可以选择参数中的某几个
- 并且可以按任意顺序传入参数
- [代码](./OptionFunc.go)

