
# 调度

### 简述 `Go` 调度流程 7

- `Go`的调度是基于`GMP`模式的，首先说一下`GMP`的含义
- `G`:表示`Goroutine`，它是一个待执行的任务
- `M`：表示操作系统的线程，它是由操作系统的调度器调度和管理
- `P`：表示处理器，它可以被看做运行在线程上的本地调度器，包含运行`Goroutine`的资源

##### 从`go func()`出发：

- 有两种存储`G`的队列，一种是处理器`P`的本地队列，一个是全局`G`队列
- 我们通过`go func()`来创建一个`Goroutine`，新创建的`G`会先保存在当前的`P`的本地队列中；
  - 如果`P`的本地队列已经满了，会把本地队列一半的`G`移动到全局队列
- `G`只能运行在`M`上，一个`M`必须持有一个`P`，`M`与`P`是近似`1:1`的关系。
- `M`会从`P`的本地队列弹出一个可执行的`G`来执行，如果`P`的队列为空：
  - `M`会尝试从全局队列拿一部分`G`(`n=len(GQ)/ GOMAXPROCS+1`)放入到`P`的本地队列，如果没拿到`G`;
  - 则随机的从`P`列表选择一个`P`，窃取其队列一半可执行的`G`；
- 当`M`执行某个`G`时，如果发生了系统调用(`syscall`)或者其余阻塞操作，`M`会阻塞：
  - 如果当前有一些`G`在执行，`runtime`会把这个线程`M`从`P`中摘除；
  - 再创建一个新的操作系统的线程(如果有空闲的线程可复用空闲线程)来服务于这个`P`；
- 当`M`系统调用结束时，阻塞时挂在`M`上的`G`会尝试获取一个空闲的`P`执行，并放入到这个`P`的本地队列：
  - 如果获取不到`P`，那么这个线程`M`变成休眠状态，加入到空闲线程中，然后这个`G`会被放入全局队列中

##### 拓展：有关概念

- 全局队列：存放等待运行的`G`
- `P`的本地队列：同全局队列类似，存放的也是等待运行的`G`，存的数据量有限：
  - 不超过`256`个。
- `P`列表(`P`的数量)：所有的`P`都再程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`个
- `M`的数量：`Go`语言启动时，会设置`M`的最大数量，默认`10000`。一个`M`阻塞了，会创建新的`M`(或者复用)
- 自旋线程：如果`M`没有`G`可执行，`M`处于自旋状态，它会不断寻找`Goroutine`
  - 最多`GOMAXPROCS`个自旋的线程，多余的会让他们休眠

##### 拓展：`P`和`M`何时被创建
- `P`：在确定`P`的最大数量`n`后，运行时系统会根据这个数量创建`n`个`P`
- `M`：没有足够的`M`来关联`P`并运行其中可运行的`G`
  - 比如所有的`M`此时都阻塞了，而`P`中还有很多就绪任务，就会去寻找空闲的`M`，没有空闲的，就会去创建新的`M`

##### 拓展：特殊的`M0`和`G0`

- `M0`
  - 是启动程序后的编号为0的主线程，这个`M`对应的实例会在全局变量`runtime.m0`中；
  - 不需要在堆(`heap`)上分配，`M0`复杂执行初始化操作和启动第一个`G`，之后`M0`就和其他的`M`一样了

- `G0`
  - `G0`是每次启动一个`M`都会第一个创建的`Goroutine`,`G0`仅用于负责调度`G`；
  - `G0`不指向任何可执行的函数，每个`M`都会有一个自己的`G0`；
  - 在调度或系统调用是会使用`G0`的栈空间，全局变量的`G0`属于`M0`
  
##### 拓展：可视化`GMP`

- `go tool trace`
- `Debug trace`

------

### `GMP`模型好处 9

- `GMP`的好处有：复用线程、减少阻塞、利用并行、抢占

- 复用线程：避免频繁的创建、销毁线程，而是对线程的复用
  - 当本线程无可执行的`G`时，尝试从其他线程绑定的`P`窃取`G`，而不是销毁线程
- 减少阻塞
  - 当本线程因为`G`进行系统调用阻塞时，线程释放绑定的`P`，把`P`转移给其他空闲的线程执行
- 利用并行
  - `GOMAXPROS`设置`P`的数量，最多有`GOMAXPROCS`个线程分布在多个`CPU`上同时运行。
- 抢占
  
##### 拓展：并行与并发

- 你吃饭吃到一半，电话来了，你停下来接了电话，接完后继续吃饭，说明支持并发
- 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，说明支持并行
- 区别在于：是否是同时

------

### 协程和进程和线程的区别？2

------

### `Go` 里面一个协程能保证绑定在一个内核线程上吗？2

------

### `Go` 的协程可以不可以自己主动让出 `CPU` 2

------

### 简述 `Go` 协程通信方式有哪些？2

------

### 简述 `Go` 伪抢占式调度 2

------

### 简述什么是`Goroutine`泄漏？1

------

### `Goroutine` 什么时候会被挂起(1)

- 在向无缓冲且没有接收者的`Channel`，或缓冲区已满的`Channel`写入数据时，`Goroutine`会挂起
- 在向无缓冲且发送者的`Channel`，或缓冲区已空的`Channel`读取数据时，`Goroutine`会挂起
- 启动`GC`瞬间(`STW`)
TODO

------

# `GC`

### 简述 `Go` 垃圾回收的流程 5

- `GOlang`的垃圾回收机制主要通过三色标记清除和写屏障来保证`GC`的高效；
- 在启动`GC`的时候先`STW`，启动相关的标记协程，然后再恢复运行。此时用户程序与标记程序同时运行；
- 当标记程序完成时，再此`STW`，此时就清理`GC`相关的数据与信息，并启动回收协程，然后再次恢复运行；
- 此时垃圾回收与用户程序同时运行，从而完成一次垃圾回收；
- 通过现在这种机制，大幅提高了垃圾回收的响应效率，减少了`STW`对用户程序的影响

##### `STW(Stop The World)`

- `Golang` 中的`STW`就是停掉所有的`Goroutine`，专心做垃圾回收，待垃圾回收结束后再恢复`Goroutine`

##### 写屏障(`Write Barries`)

- 写屏障就是让`Goroutine`与`GC`同时运行的手段，减少`STW`的时间
- 写屏障类似一种开关，在`GC`的特定时机开启，开启后指针传递时会把指针标记(即对象指向关系发生变化时，被指向的对象标记为灰色)，即本轮不回收，下次`GC`时再确定

##### 辅助`GC`(`Mutator Assist`)

- 为了防止内存分配过快，在`GC`执行过程中，如果`Goroutine`需要分配内存，那么这个`Goroutine`会参与一部分`GC`的工作，即帮助`GC`做一部分工作

##### 三色标记清除

- 三色含义
  - 白色对象：潜在可能被回收的对象，如果标记完成后，白色对象会被回收
  - 黑色对象：正在被使用的对象，黑色对象中任何一个指针都可能直接到达白色对象，该对象已经扫描完毕
  - 灰色对象：已被回收器访问到的对象，但灰色对象仍有可能指向白色对象下，故需要继续扫描
- 在垃圾回收器开始工作时，程序中不存在任何的黑色对象，垃圾收集器的根对象会被标记成灰色对象，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束

------

### 两次 `GC` 周期重叠会引发什么问题，`GC` 触发机制是什么样的？4

##### 两次 `GC` 周期重叠会引发什么问题

TODO

##### `GC`启动的三种情况

- 后台触发
  - 会在后台开启一个强制触发垃圾收集的`Gorotine`，默认每2分钟，进行一次检查和垃圾收集
- 手动触发
  - 通过`runtime.GC`这个函数手动触发
- 申请内存

------

### 内存逃逸

------

# 数据结构

### `Go` 是如何实现 `map` 5





##### 拓展：拉链法

- 实现拉链法一般使用链表+数组
- 写入数据：先通过哈希函数对键进行哈希，得到一个数组的`index`，然后判断该数组位置的链表中是否存在该键，如果存在则更新数据，否则在链表末尾追加新的键值对

##### 拓展：开放寻址法：

- 核心思想：依次探测和比较数组中的元素，以判断目标键值对是否存在于哈希表中
- 写入数据：当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置
- 查找数据：先获取键的哈希并取模，然后找到对应位置，判断该位置的键和目标是否一致，不一致就会继续查找后面的元素，直到内存为空或者找到目标元素

------

### `Map`是线程安全的吗？怎么解决并发安全问题？2

- `Map`不是线程安全的；
- 解决方法：
  - 通过读写锁(`sync.RWMutex`)实现对`map`的并发访问

------

### 简述 `defer` 的特性，及 `defer` 的执行顺序 4

- `Go`语言的`defer`会在当前函数返回前，执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源

##### `defer`中主要有两个特性

  - 后调用的`defer` 函数会先执行

    - `Go`语言的编译器会将`defer`转换成`runtime.deferproc`，还会在调用`defer`的函数结尾插入`runtime.deferreturn`；
    - `runtime.deferproc` 会为`defer`创建一个新的`runtime._defer`结构体，并将它追加到所在`Goroutine _defer` 链表的最前面
    - `runtime.deferreturn`会从`Goroutine` 的`_defer`链表中取出最前面的`runtime._derfer` 进行处理

- 函数的参数会被预先计算

  - 调用`runtime.deferproc`函数创建新的延迟调用时，就会立刻拷贝参数，函数的参数不会等到真正执行时计算

  ```go
  func main() {
  	for i := 0; i < 3; i++ {
  		defer fmt.Println(i) // 输出：2,1,0，因为i是延迟函数的参数，被拷贝了
  		defer func() {
  			fmt.Println(i)     // 输出：3,3,3,因为此时的i属于外部函数，没有被拷贝
  		}()
  	}
  }
  ```

##### 拓展：为什么`recover`只能在`defer`中，才能终止`panic` 造成的程序崩溃？

```go
func main() {
	defer fmt.Println("in main") // 会被打印
	if err := recover(); err != nil {
  	fmt.Println(err)           // 不会被打印
  }
  panic("unknown err")
}
```

- 在`Go`语言中，将`panic`和 `recover` 分别转换为`runtime.gopanic`和`runtime.gorecover`
- 在运行过程中遇到`runtime.gopanic`方法时，主要操作是：
  - 创建新的`runtime._painc`结构体，并添加到所在`Goroutine`的`_painc`链表的最前端；
  - 为了保证一些收尾工作能安全完成，会从所在`Goroutine`的 `_defer`中依次取出延迟函数进行处理；
  - 然后判断当前`runtime._painc`结构体中的`recovered`值，如果为`true`则调用`runtime.recovery`，进行错误处理并恢复到正常的执行流程，如果为`flase`则调用`fatalpanic`终止程序
- 在运行过程中遇到`runtime.gorecover`方法时，主要是将所在`Goroutine`的`_panic`链表第一个`runtime._panic`的`recovered`值设为`true`
- 所以说，如果不将`recover`函数包在`defer`中，发生`panic`时则无法被调用到，也无法设置`runtime._panic recovered = true`，`panic`就会导致程序崩溃。

------

### `slice` 的底层原理，`slice` 和数组的区别是什么？3

- `Slice`的底层主要是包括：一个指向底层数组的指针、切片的长度`len`、底层数组的容量`cap`；
- `Slice`作为参数传递是值传递，因为他的值包含了底层数组的指针，所以被调用的函数修改切片值时，是同一指针指向的数组被修改，原切片会受影响；但是如果在追加元素时，因为原切片的固定长度不会发生变化，所以原切片不会改变。这就是我们写 `arr = append(arr, 1)`时为什么要用把结果赋值给原变量；
- 使用`append` 进行追加时，我们会先从切片中获取它的数组指针、大小和容量，如果追加元素后切片的大小大于容量，则需要扩容，在分配内存空间前，需要确定新的切片容量：
  - 如果期望容量大于当前容量的两倍，则使用期望容量，否则进行下一步处理；
  - 如果当前切片的长度小于1024，则将容量翻倍，否则进行一下步处理；
  - 不符合上述两点，通过每次给增加`25%`的容量，直到新容量大于期望容量

##### `slice`和数组的区别

- `Go`语言数组在初始化后大小无法改变，所以创建时必须指定数组的大小
- `Go`语言的切片是动态数组，长度并不固定，可以向切片追加元素，它会在容量不足时自动扩容。

------

### 有缓存的管道和没有缓存的管道区别 3

- `Go` 中有缓冲和无缓冲的 `Channel`区别是，有缓冲的是同步，无缓冲的是异步
- 打个比方，邮差送信
    - 无缓冲的管道，邮差送信到你家门口，如果你不在家，他不走，你一定要接下信，他才会走；
      - 也就是无缓冲的`Channel`必须有接收值，否则会阻塞；
    - 有缓冲的管道，邮差送信到你家，直接把信放到信箱中，就可以走了，如果你的信箱满了，他需要等待信箱腾出位置才能走；
      - 也就是有缓冲的`Channel`如果有空闲，可以把数据写入，然后处理结束；
      - 如果缓冲区被写满，则`Goroutine`被阻塞，需要等待缓冲区腾出位置被它写入，处理才算完成。

------

### `channel` 怎么实现线程安全

```go
type hchan struct {
	buf      unsafe.Pointer // 保存数队列
	sendx    uint           // 发送数据位置
	recvx    uint           // 接收数据位置
	recvq    waitq          // 等待接收的Goroutine队列
	sendq    waitq          // 等待写入的Goroutine队列
	lock mutex
}
```

- `Channel`在运行时的内部表示是`runtime.hchan`，该结构体中包含了用于保护成员变量的互斥锁，从某种程度上说，`Channel`是一个用于同步和通信的有锁队列；
- 同时`runtime.hchan`有一个循环队列(`buf`)、读取和写入队列的标记位`sendx`(`send index`)和`recv`(`receive index`)，用于数据的循环写入和顺序写入；
- `runtime.hchan`有发送队列(`sendq`)和接收队列(`recvx`)，使得数据的发送和接收的先进先出(`FIFO`)，提供了安全性；

##### `Channel`收发数据

- 当读`Gorotine G1`向`Channel`发送数据时，首先需要获取锁，拿到锁，发送数据可能会发生下面3种情况：
  - 1-如果当前`Channel`的`recvq`上存在已经被阻塞的`Goroutine`，将数据发送给队列的第一个接收者,并将其设置下一个运行的`Goroutine`；
  - 2-如果`Channel`存在缓冲区且有空闲的容量，则会直接将数据存储到缓冲区，`sendx`所在的位置上；
  - 3-如果不满足上面的两种情况，，则会挂起当前`Goroutine`，并将它加入`sendq`队列末尾；
- 处理完上述三种情况后，释放锁；

- 当`G2`读取`Channel`的数据时，先获取锁，拿到锁后，接收数据可能会发送下面4中种情况：
  - 1-如果`Channel`为`nil`，那么会直接调用`runtime.gopark`挂起当前`Goroutine`；
  - 2-如果`Channel`已经关闭并且缓冲区没有任何数据，会直接返回；
  - 3-如果`Channel`的缓冲区中包含数据，那么直接读取`recvx`索引对应的数据；
    - 接收完后判断`sendq`是否有挂起的`Goroutine`；
    - 如果有则将`sendq`队列中第一个`Goroutine`的数据拷贝到缓冲区；
  - 4-如果当前缓冲区没有数据，则会挂起当前`Goroutine`，并将它加入`recvq`队列末尾
- 处理完上面情况后，释放锁。

------

### `make`和`new` 的区别

- `make`的作用是创建切片、哈希表和`Channel`等内置的数据结构
- `new`的作用是为类型申请一块内存空间，并返回指向这块内存的指针

------

# 其他

### `Go` 有哪些优缺点、错误处理有什么优缺点？4

------

### 平时写`go`，怎么调试的？有做过`test`和`benchmark`吗？1

------

