
# 调度

### 简述 `Go` 调度流程 7

### `GMP` 及该模型好处 9

### 协程和进程和线程的区别？2

### `Go` 里面一个协程能保证绑定在一个内核线程上吗？2

### `Go` 的协程可以不可以自己主动让出 `CPU` 2

### 简述 `Go` 协程通信方式有哪些？2

### 简述 `Go` 伪抢占式调度 2

### 简述什么是`goroutine`泄漏？1

### `groutinue` 什么时候会被挂起 1

# `GC`

### 简述 `Go` 垃圾回收的流程 5

### 两次 `GC` 周期重叠会引发什么问题，`GC` 触发机制是什么样的？4

### 内存逃逸

# 数据结构

### `Go` 是如何实现 `map` 5





##### 拓展：拉链法

- 实现拉链法一般使用链表+数组
- 写入数据：先通过哈希函数对键进行哈希，得到一个数组的`index`，然后判断该数组位置的链表中是否存在该键，如果存在则更新数据，否则在链表末尾追加新的键值对

##### 拓展：开放寻址法：

- 核心思想：依次探测和比较数组中的元素，以判断目标键值对是否存在于哈希表中
- 写入数据：当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置
- 查找数据：先获取键的哈希并取模，然后找到对应位置，判断该位置的键和目标是否一致，不一致就会继续查找后面的元素，直到内存为空或者找到目标元素

### `Map`是线程安全的吗？怎么解决并发安全问题？2

### 简述 `defer` 的特性，及 `defer` 的执行顺序 4

- `Go`语言的`defer`会在当前函数返回前，执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源

##### `defer`中主要有两个特性

  - 后调用的`defer` 函数会先执行

    - `Go`语言的编译器会将`defer`转换成`runtime.deferproc`，还会在调用`defer`的函数结尾插入`runtime.deferreturn`；
    - `runtime.deferproc` 会为`defer`创建一个新的`runtime._defer`结构体，并将它追加到所在`Goroutine _defer` 链表的最前面
    - `runtime.deferreturn`会从`Goroutine` 的`_defer`链表中取出最前面的`runtime._derfer` 进行处理

- 函数的参数会被预先计算

  - 调用`runtime.deferproc`函数创建新的延迟调用时，就会立刻拷贝参数，函数的参数不会等到真正执行时计算

  ```go
  func main() {
  	for i := 0; i < 3; i++ {
  		defer fmt.Println(i) // 输出：2,1,0，因为i是延迟函数的参数，被拷贝了
  		defer func() {
  			fmt.Println(i)     // 输出：3,3,3,因为此时的i属于外部函数，没有被拷贝
  		}()
  	}
  }
  ```

##### 拓展：为什么`recover`只能在`defer`中，才能终止`panic` 造成的程序崩溃？

```go
func main() {
	defer fmt.Println("in main") // 会被打印
	if err := recover(); err != nil {
  	fmt.Println(err)           // 不会被打印
  }
  panic("unknown err")
}
```

- 在`Go`语言中，将`panic`和 `recover` 分别转换为`runtime.gopanic`和`runtime.gorecover`
- 在运行过程中遇到`runtime.gopanic`方法时，主要操作是：
  - 创建新的`runtime._painc`结构体，并添加到所在`Goroutine`的`_painc`链表的最前端；
  - 为了保证一些收尾工作能安全完成，会从所在`Goroutine`的 `_defer`中依次取出延迟函数进行处理；
  - 然后判断当前`runtime._painc`结构体中的`recovered`值，如果为`true`则调用`runtime.recovery`，进行错误处理并恢复到正常的执行流程，如果为`flase`则调用`fatalpanic`终止程序
- 在运行过程中遇到`runtime.gorecover`方法时，主要是将所在`Goroutine`的`_panic`链表第一个`runtime._panic`的`recovered`值设为`true`
- 所以说，如果不将`recover`函数包在`defer`中，发生`panic`时则无法被调用到，也无法设置`runtime._panic recovered = true`，`panic`就会导致程序崩溃。

### `slice` 的底层原理，`slice` 和数组的区别是什么？3

- `Slice`的底层主要是包括：一个指向底层数组的指针、切片的长度`len`、底层数组的容量`cap`；
- `Slice`作为参数传递是值传递，因为他的值包含了底层数组的指针，所以被调用的函数修改切片值时，是同一指针指向的数组被修改，原切片会受影响；但是如果在追加元素时，因为原切片的固定长度不会发生变化，所以原切片不会改变。这就是我们写 `arr = append(arr, 1)`时为什么要用把结果赋值给原变量；
- 使用`append` 进行追加时，我们会先从切片中获取它的数组指针、大小和容量，如果追加元素后切片的大小大于容量，则需要扩容，在分配内存空间前，需要确定新的切片容量：
  - 如果期望容量大于当前容量的两倍，则使用期望容量，否则进行下一步处理；
  - 如果当前切片的长度小于1024，则将容量翻倍，否则进行一下步处理；
  - 不符合上述两点，通过每次给增加`25%`的容量，直到新容量大于期望容量

##### `slice`和数组的区别

- `Go`语言数组在初始化后大小无法改变，所以创建时必须指定数组的大小
- `Go`语言的切片是动态数组，长度并不固定，可以向切片追加元素，它会在容量不足时自动扩容。

### 有缓存的管道和没有缓存的管道区别 3

### `channel` 怎么实现线程安全 2

# 其他

### `Go` 有哪些优缺点、错误处理有什么优缺点？4

### 平时写`go`，怎么调试的？有做过`test`和`benchmark`吗？1

### `make`和`new` 的区别

- `make`的作用是创建切片、哈希表和`Channel`等内置的数据结构
- `new`的作用是为类型申请一块内存空间，并返回指向这块内存的指针
