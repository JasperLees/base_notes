
## 数据结构

#### Redis 有几种数据结构？Zset 是如何实现的？

#### 简述 Redis 中跳表的应用以及优缺点

#### 简述 Redis 中常见类型的底层数据结构

#### `Redis` 如何实现延时队列?

- 延时队列可以通过 `Redis` 的 `zset` 来实现。
- 我们将消息序列号一个字符串作为 `zset` 的 `value`，这个消息的到期处理时间作为 `score`，然后用多线程轮询 `zset` 获取到期的任务进行处理。
- 多线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。
- 因为有多线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。
- `zset` 的 `zrem` 方法是多线程争抢任务的关键，它的返回值决定了当前线程有没有抢到任务。

##### 拓展：重试机制

- 如果线程抢到任务后，执行失败(如：更新事务失败)，需要考虑到重试机制
- 可将任务重新 `zadd` 回到延时队列中，设置下一次执行的时间，但要考虑到不能无限重试，所以消息内容最好带重试了几次，以控制频率。
- 如果该任务是处理多个子任务，还需要考虑到幂等操作，例如：更新业务时，先查询该任务是否已经存在记录。

#### `Redis` 分布式锁的实现原理？

- 使用分布式锁的目的，帮助不同进程以互斥的方式使用共享资源。
- `Redis`的分布式锁实现方案，分为单个实例和多个实例

##### 单个实例

- 获得锁的方式：`SET key value NX EX 10`
  - `NX`：就是 `setnx`，仅不 `key`, 不存在才可以被赋值
  - `EX 10`: 增加过期时间是为了解决死锁问题，因为进程在执行期间可能发生故障，锁得不到释放
  - `value`：该值表示拥有锁的客户端标识，这个标识可以使用客户端`ID` + 微秒级时间戳
- 为什么要设置客户端标识？
  - 客户端`A`获取该锁后，在某些操作中被阻塞时间超过该锁的有效时间，导致锁被释放掉。
  - 客户端`B`在获取锁后，进行其他操作时，客户端`A`完成操作后，会删除客户端`B`以及获取的锁。
  - 增加客户端标识的目的是为了线程安全，客户端`A`在删除锁时，需要先判断该锁释放属于自己

- 删除锁：先判断，后删除，必须原子操作，需使用 `Lua` 脚本

  ```lua
  if redis.call("get", KEYS[1] == ARGV[1]) then
  	return redis.call("del", KEY[1])
  else
  	return 0
  end
  ```

##### 为什么要多个`Redis master` 节点

- 因为`Redis` 的复制是异步的
- 假如客户端`A`获得主服务器期间，在主从同步前，主机崩溃，这时客户端`B`可以获取该锁，导致不安全。
- 所以，在特殊情况下(如：故障)，多个客户端可以同时持有锁会保证资源的安全性。

##### 多个实例-`Redlock`算法

- 假设有`N` 个 `Reids master`，这些节点完全独立，不使用复制，客户端执行过程：
  - 获取当前时间设为 `T1`，设该锁的过期时间为 `10s`
  - 通过遍历，使用相同的`key` 和客户端标识来获取锁，获取当前锁的时间戳是`T2`，锁的存活时间为`T3 = 10 + T1 - T2` 。
  - 当客户端获取半数`(N/2+1)` 以上的锁，则证明获取该分布式锁。
- 故障考虑
  - 为了防止客户端长时间与故障状态的`Redis`节点通信时保持阻塞，客户端应设置合理的超时时间，如果一个实例不可用，我们应该尝试与下一个实例尽快通信
- 释放锁
  - 只需要在所有实例中释放锁，无论客户端之前是否成功获取分布式锁。



## 数据保存

#### 简述 `Redis` 持久化中 `rdb` 以及 `aof` 方案的优缺点

#### `Redis` 序列化有哪些方式？

#### 简述 `Redis` 的过期机制和内存淘汰策略

##### 过期机制

- `Redis`会将每个设置了过期时间的`key`放入一个独立的字典中，以后会定时扫描这个字典来删除到期的`key`。
- 除了定时遍历外，还会使用惰性策略来删除过期的`key`，所谓惰性策略就是在客户的访问这个`key` 时，`Redis`会对 `key`的过期时间进行检查，如果过期了就立即删除。
- 定时删除是集中处理，惰性删除是零散处理

##### 定期扫描策略

`Redis` 默认每 `100ms` 采用一一种简单的贪心策略进行扫描

1. 从过期字典中随机20个`key`;
2. 删除这20个`key`中已经过期的 `key`;
3. 如果过期的`key`比率超过 `1/4`，那么重复步骤1；
4. 为了保证过期扫描不会过度重复，导致线程卡死，扫描时间上限默认不会超过`25ms`

##### 内存淘汰机制

为了限制最大使用内存，当实际内存超出 `maxmemory`时，`Redis`提供了几种可选策略(`maxmemory-policy`) 来让用户自己决定该如何腾出新的空间以继续提供读写服务

- `noeviction`：不会继续服务写请求(`DEL`除外)，读请求可以继续，保证不会丢失数据，但会让线上的业务不能持续进行。这是默认的淘汰策略
- `volatile-lru`：从设置了过期时间的`key`中，最少使用的 `key`优先被淘汰。保证没设置过期时间的 `key` 不会被淘汰
- `volatile-ttl`：从设置了过期时间的`key`中，剩余存活时间(`ttl`)最短的被淘汰
- `volatile-random`：从设置了过期时间的`key`中，随机淘汰
- `allkeys-lru`：和 `volatile-lru` 的区别是从全体`key` 中选择
- `allkeys-ttl` : `volatile-ttl` 的区别是从全体`key` 中选择
- `allkeys-random` : `volatile-rand` 的区别是从全体`key` 中选择

`allkeys-xxx`只适合做缓存，如果想使用持久化，就要用 `volatile-xxx`

#### 假设 `Redis` 的 `master` 节点宕机了，你会怎么进行数据恢复？

## 高可用

#### 简述 `Redis` 中如何防止缓存雪崩和缓存击穿

##### 缓存击穿的含义

- 某个热点数据失效，大量针对这个数据的请求会穿透到数据源，也就是大量请求到了`DB`

##### 缓存穿透的解决方案

- 使用互斥锁更新，保证同一个进程针对同一个数据不会并发请求到 `DB`，减小`DB`压力
- 使用随机退避方法，失效时随机 `sleep` 一个很短的时间，再次查询，如果失败再执行更新。

##### 缓存雪崩含义：

- 原因

  1、`Redis` 挂掉，请求全部走数据库

  2、对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库

- 原因1解决方案

  事发前：实现 `Redis` 的高可用(主从架构 + `Redis Cluster`)，尽量避免 `Redis` 挂掉这种情况

  事发中：万一 `Redis` 挂掉，可以设置本地缓存 + 限流，尽量避免数据库被干掉(起码能保证服务还是能正常工作)

  事发后：`Redis` 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据

- 原因2解决方案

  针对多个热点 `key` 同时失效问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 `key` 同一时刻失效 

#### 简述 Redis 的哨兵机制

#### Redis 中，sentinel 和 cluster 的区别和适用场景是什么？

## 特性

#### 为什么 `Redis` 在单线程下能如此快？

- 纯内存操作，`Redis`将数据存储在内存中，读写数据是都不会收到磁盘`I/O`的限制；
- 灵活多样的数据结构，针对不同的场景使用对于的数据类型，减少内存使用的同时，节省网络流量传输；
- 单线程操作，避免上下文切换和竞争条件，不用考虑各种锁的问题，如：释放锁、死锁等；
- 采用了非阻塞`I/O` 多路复用机制；
- 使用底层模型不同，`Redis` 直接自己构建了`VM`机制，减少调用系统函数的时间浪费

##### 拓展：`Redis`的非阻塞`I/O`多路复用机制

- `Redis`会将每个客户端套接字都关联一个指令队列。客户端的指令队列排队过来进行顺序处理，先到先得；
- `Redis` 也会为每个客户端套接字关联一个响应的队列。`Redis`服务器通过响应队列来将指令的返回结果回复给客户端。
- 如果响应队列为空，意味着连接暂时处于空闲状态，不需要去获取写事件，可以将当前客户端的描述符从 `write_fds`里移出来。等队列有数据了，再将描述符放进去。

##### 拓展：`Redis`的`VM`机制

- `Redis` 的 `VM`(虚拟内存)机制是，暂时把不经常访问的数据(冷数据)从内存交换到磁盘中；
- 通过`VM`功能实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘中。这样可以避免因为内存不足而造成访问速度下降的问题；
- `Redis`为了保证查找的速度，只会将`value`交换出去，而在内存中保留所有的`Key`。所以非常适合`Key`很小、`value `很大的情况；
- `Redis`并没有使用 `OS`提供的 `Swap`，而是自己实现
