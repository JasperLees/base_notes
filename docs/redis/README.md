
# 数据结构

### `Redis` 有几种数据结构？`Zset` 是如何实现的？

------

### 简述 `Redis` 中跳表的应用以及优缺点

------

### 简述 `Redis` 中常见类型的底层数据结构

------

### `Redis` 如何实现延时队列?

- 延时队列可以通过 `Redis` 的 `zset` 来实现。
- 我们将消息序列号一个字符串作为 `zset` 的 `value`，这个消息的到期处理时间作为 `score`，然后用多线程轮询 `zset` 获取到期的任务进行处理。
- 多线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。
- 因为有多线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。
- `zset` 的 `zrem` 方法是多线程争抢任务的关键，它的返回值决定了当前线程有没有抢到任务。

##### 拓展：重试机制

- 如果线程抢到任务后，执行失败(如：更新事务失败)，需要考虑到重试机制
- 可将任务重新 `zadd` 回到延时队列中，设置下一次执行的时间，但要考虑到不能无限重试，所以消息内容最好带重试了几次，以控制频率。
- 如果该任务是处理多个子任务，还需要考虑到幂等操作，例如：更新业务时，先查询该任务是否已经存在记录。

------

### `Redis` 分布式锁的实现原理？

- 使用分布式锁的目的，帮助不同进程以互斥的方式使用共享资源。
- `Redis`的分布式锁实现方案，分为单个实例和多个实例

##### 单个实例

- 获得锁的方式：`SET key value NX EX 10`
  - `NX`：就是 `setnx`，仅不 `key`, 不存在才可以被赋值
  - `EX 10`: 增加过期时间是为了解决死锁问题，因为进程在执行期间可能发生故障，锁得不到释放
  - `value`：该值表示拥有锁的客户端标识，这个标识可以使用客户端`ID` + 微秒级时间戳
- 为什么要设置客户端标识？
  - 客户端`A`获取该锁后，在某些操作中被阻塞时间超过该锁的有效时间，导致锁被释放掉。
  - 客户端`B`在获取锁后，进行其他操作时，客户端`A`完成操作后，会删除客户端`B`以及获取的锁。
  - 增加客户端标识的目的是为了线程安全，客户端`A`在删除锁时，需要先判断该锁释放属于自己

- 删除锁：先判断，后删除，必须原子操作，需使用 `Lua` 脚本

  ```lua
  if redis.call("get", KEYS[1] == ARGV[1]) then
  	return redis.call("del", KEY[1])
  else
  	return 0
  end
  ```

##### 为什么要多个`Redis master` 节点

- 因为`Redis` 的复制是异步的
- 假如客户端`A`获得主服务器期间，在主从同步前，主机崩溃，这时客户端`B`可以获取该锁，导致不安全。
- 所以，在特殊情况下(如：故障)，多个客户端可以同时持有锁会保证资源的安全性。

##### 多个实例-`Redlock`算法

- 假设有`N` 个 `Reids master`，这些节点完全独立，不使用复制，客户端执行过程：
  - 获取当前时间设为 `T1`，设该锁的过期时间为 `10s`
  - 通过遍历，使用相同的`key` 和客户端标识来获取锁，获取当前锁的时间戳是`T2`，锁的存活时间为`T3 = 10 + T1 - T2` 。
  - 当客户端获取半数`(N/2+1)` 以上的锁，则证明获取该分布式锁。
- 故障考虑
  - 为了防止客户端长时间与故障状态的`Redis`节点通信时保持阻塞，客户端应设置合理的超时时间，如果一个实例不可用，我们应该尝试与下一个实例尽快通信
- 释放锁
  - 只需要在所有实例中释放锁，无论客户端之前是否成功获取分布式锁。

------

# 数据保存

### 简述 `Redis` 持久化中 `rdb` 以及 `aof` 方案的优缺点

------

### `Redis` 序列化有哪些方式？

------

### 简述 `Redis` 的过期机制和内存淘汰策略

##### 过期机制

- `Redis`会将每个设置了过期时间的`key`放入一个独立的字典中，以后会定时扫描这个字典来删除到期的`key`。
- 除了定时遍历外，还会使用惰性策略来删除过期的`key`，所谓惰性策略就是在客户的访问这个`key` 时，`Redis`会对 `key`的过期时间进行检查，如果过期了就立即删除。
- 定时删除是集中处理，惰性删除是零散处理

##### 定期扫描策略

`Redis` 默认每 `100ms` 采用一一种简单的贪心策略进行扫描

1. 从过期字典中随机20个`key`;
2. 删除这20个`key`中已经过期的 `key`;
3. 如果过期的`key`比率超过 `1/4`，那么重复步骤1；
4. 为了保证过期扫描不会过度重复，导致线程卡死，扫描时间上限默认不会超过`25ms`

##### 内存淘汰机制

为了限制最大使用内存，当实际内存超出 `maxmemory`时，`Redis`提供了几种可选策略(`maxmemory-policy`) 来让用户自己决定该如何腾出新的空间以继续提供读写服务

- `noeviction`：不会继续服务写请求(`DEL`除外)，读请求可以继续，保证不会丢失数据，但会让线上的业务不能持续进行。这是默认的淘汰策略
- `volatile-lru`：从设置了过期时间的`key`中，最少使用的 `key`优先被淘汰。保证没设置过期时间的 `key` 不会被淘汰
- `volatile-ttl`：从设置了过期时间的`key`中，剩余存活时间(`ttl`)最短的被淘汰
- `volatile-random`：从设置了过期时间的`key`中，随机淘汰
- `allkeys-lru`：和 `volatile-lru` 的区别是从全体`key` 中选择
- `allkeys-ttl` : `volatile-ttl` 的区别是从全体`key` 中选择
- `allkeys-random` : `volatile-rand` 的区别是从全体`key` 中选择

`allkeys-xxx`只适合做缓存，如果想使用持久化，就要用 `volatile-xxx`

------

### 假设 `Redis` 的 `master` 节点宕机了，你会怎么进行数据恢复？

------

# 高可用

### 简述一致性哈希算法的实现方式及原理


##### 一致性哈希解决的问题

- `hash` 取模的方式，在缓存系统增加缓存或减少节点时，导致大量的缓存命不中；
- 缓存数据需要重新建立，甚至是整体的缓存数据迁移，瞬间会给 `DB`带来极高的系统负载，甚至导致 `DB`服务器宕机

##### 原理

- 一致性哈希，是一种特殊的哈希算法。
- 在使用一致哈希算法后，哈希表槽位数(大小)的改变平均只需对 `k/n`个关键字重新映射，`k`是`key`的数量，`n`是`Server`的数量。
- 在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射；

##### 实现

- 一致性哈希将整个哈希值空间组织成一个虚拟的圆环，假设某哈希函数 `H` 的值空间是 `0-2^32-1`(哈希值是32位无符号整形)；
- 整个空间按顺时针方向组织，`0`和`2^32-1`在零点方向重合。
- 将各个服务器的 `ip`或主机名 为关键字用 `H` 进行一个哈希计算，确定每台机器在环上的位置；
- 将数据 `key` 使用相同的函数 `H` 计算出哈希值 `idx`, 然后根据`idx`确定此数据在环上的位置，从此位置沿环顺时针行走，第一台遇到的服务器就是其应该定位到的服务器。

##### 容错性与可扩展性分析

- 容错性
  - 假如有三台服务器 `Server1、Sever2、Server3` 分别落在环上，通过`H`算法将`A`存放在 `Server1`、`B`存放在`Server2`，`C`存放在`Server3`；
  - 假设 `Server 3`宕机了，`A、B`节点不会受影响，`C`会顺着环往下走，遇到了`Server 1`；
  - 在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅是此服务器到其环空间中前一台服务器(逆时针方向第一台)之间的数据，其它不会受到影响
  
- 可扩展性分析
  - 接上面的情况，现在想增加一台 `Server 4`在 `Server 3`位置，则`C`会被重新定位到 `Server 4` 上；
  - 如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器(逆时针方向第一台)之间的数据，其它不受影响
  
- 综上所述，一致性哈希算法对节点的增减都只需重定位环空间的一小部分数据，具有较好的容错性和可扩展性

##### 存在问题

- 上面部分主要是面向`Redis`节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题；
- 假如我们的系统有两台`Redis`，服务器落在环上的位置比较近，会产生一种情况，`Server 1` 的`hash`范围比`Server 2`的`hash`范围大，导致数据大部分都存储在`Server 1`中，数据存储不平衡；

##### 虚拟节点

- 为了解决这种数据存储不平衡的问题，一致性哈希算法引入虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点；
- 例如：`Server 1` 可以编号为 `Server1#1`、`Server1#2`
- 在实际应用中，通常将虚拟节点数设置为 32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。

------

### 简述 `Redis` 中如何防止缓存雪崩和缓存击穿

##### 缓存击穿的含义

- 某个热点数据失效，大量针对这个数据的请求会穿透到数据源，也就是大量请求到了`DB`，如果此时有大量的并发请求过来，会导致`DB`被压垮

##### 缓存穿透的解决方案

- 使用互斥锁(分布式锁)更新，保证同一个进程针对同一个数据不会并发请求到 `DB`，减小`DB`压力
- 使用随机退避方法，失效时随机 `sleep` 一个很短的时间，再次查询，如果失败再执行更新。

##### 缓存雪崩含义：

- 原因
  1、`Redis` 挂掉，请求全部走数据库
  2、对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库
- 原因1解决方案
  事发前：实现 `Redis` 的高可用(主从架构 + `Redis Cluster`)，尽量避免 `Redis` 挂掉这种情况
  事发中：万一 `Redis` 挂掉，可以设置本地缓存 + 限流，尽量避免数据库被干掉(起码能保证服务还是能正常工作)
  事发后：`Redis` 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据
- 原因2解决方案
  针对多个热点 `key` 同时失效问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 `key` 同一时刻失效 

##### 拓展：缓存穿透

- 缓存穿透含义：
  - 查询一个一定不存在的数据。由于缓存不命中，并且处于容错考虑，如果从数据库查不到则不写入缓存，这导致不存在的数据每次请求都要到数据库去查询，失去缓存的意义。
  - 请求数据大量不命中，导致请求走了数据库，产生这个问题的原因可能是外部的恶意攻击

- 缓存穿透的解决方案：
  - 接口层增加校验，用户鉴权校验，参数校验
  - 从数据库找不到时，也将空对象设置到缓存里，给空对象设置一个较短的过期时。

- 存在问题
  - 如果有大量获取未注册用户信息的请求，缓存内就会有大量的空值缓存，也就会浪费缓存的存储空间，空间被占满，还会剔除一些已被缓存的用户信息，反而会造成缓存命中率降低
  - 使用 `BloomFilter` 布隆过滤器(位数组)，特点是存在性检测，判断 `key` 是否在数据库中存在，如果不在 `BloomFilter` 中不存在，则数据也一定不存在。适合解决这类的问题。(时间复杂度`O(1)`)

- 缺陷1：有一定错误几率（`Hash`碰撞)
  - 解决：多个`Hash` 算法为元素算出 `index`，当所有值为1才认为元素在集合中。

- 缺陷2:不支持删除元素(`Hash`碰撞导致`A`,`B`同一个`index`)
  - 解决：将 `bit` 位改为存储数值，进行 `+1 -1`

- 布隆过滤器使用场景：资讯app的新闻展示，给用户推送新的资讯用来过滤哪些用户已经浏览过了

##### 拓展：`Linux`惊群效应

- 也叫雷鸣群体效应；
- 就是多进程(多线程)在同时阻塞等待同一个事件的适合(休眠状态)，如果等待的这个事件发生，那么它就会唤醒等待的所有进程(或者线程)；
- 但最终却只能有一个进程(线程)获得这个时间的控制权，对该事件进行处理；而其他进程(线程)获取控制权失败，只能重新进入休眠状态；
- 这种现象和性能浪费就叫惊群效应。

------

### 简述 Redis 的哨兵机制

------

### Redis 中，sentinel 和 cluster 的区别和适用场景是什么？

------

# 特性

### 为什么 `Redis` 在单线程下能如此快？

- 纯内存操作，`Redis`将数据存储在内存中，读写数据是都不会收到磁盘`I/O`的限制；
- 灵活多样的数据结构，针对不同的场景使用对于的数据类型，减少内存使用的同时，节省网络流量传输；
- 单线程操作，避免上下文切换和竞争条件，不用考虑各种锁的问题，如：释放锁、死锁等；
- 采用了非阻塞`I/O` 多路复用机制；
- 使用底层模型不同，`Redis` 直接自己构建了`VM`机制，减少调用系统函数的时间浪费

##### 拓展：`Redis`的非阻塞`I/O`多路复用机制

- `Redis`会将每个客户端套接字都关联一个指令队列。客户端的指令队列排队过来进行顺序处理，先到先得；
- `Redis` 也会为每个客户端套接字关联一个响应的队列。`Redis`服务器通过响应队列来将指令的返回结果回复给客户端。
- 如果响应队列为空，意味着连接暂时处于空闲状态，不需要去获取写事件，可以将当前客户端的描述符从 `write_fds`里移出来。等队列有数据了，再将描述符放进去。

##### 拓展：`Redis`的`VM`机制

- `Redis` 的 `VM`(虚拟内存)机制是，暂时把不经常访问的数据(冷数据)从内存交换到磁盘中；
- 通过`VM`功能实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘中。这样可以避免因为内存不足而造成访问速度下降的问题；
- `Redis`为了保证查找的速度，只会将`value`交换出去，而在内存中保留所有的`Key`。所以非常适合`Key`很小、`value `很大的情况；
- `Redis`并没有使用 `OS`提供的 `Swap`，而是自己实现

------
